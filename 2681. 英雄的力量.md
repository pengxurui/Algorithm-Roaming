## [2681. 英雄的力量](https://leetcode.cn/problems/power-of-heroes/)

## 题目描述

给你一个下标从 0 开始的整数数组 nums ，它表示英雄的能力值。如果我们选出一部分英雄，这组英雄的 力量 定义为：

i0 ，i1 ，... ik 表示这组英雄在数组中的下标。那么这组英雄的力量为 max(nums[i0],nums[i1] ... nums[ik])2 * min(nums[i0],nums[i1] ... nums[ik]) 。
请你返回所有可能的 非空 英雄组的 力量 之和。由于答案可能非常大，请你将结果对 109 + 7 取余。

### 问题结构化

![](https://pic.leetcode.cn/1684079722-KJBcZj-104-T4.jpg){:width=400}

#### 1、概括问题目标

计算所有组合方案的「力量」总和。

#### 2、分析问题要件

枚举所有子集，计算子集的力量值计算公式为$「最大值^2*最小值」$。

#### 3、观察问题数据

- 数据量：问题数据量上界为 $10^5$，要求算法时间复杂度低于 $O(n^2)$；
- 数据大小：元素值的上界为 $10^9$，乘法运算会溢出整型上界，需要考虑大数问题。

#### 4、观察问题测试用例：

以数组 nums=[1, 2, 3] 为例：

- 分析小规模问题：[] 空集的力量值是 0，只包含 1 个元素子集的力量值计算也没有问题；

| 子集 | 最大值 | 最小值 | 力量值 |
| --- | --- | --- | --- |
| {} | 0 | 0 | 0 |
| {1} | 1 | 1 | $1^2*1$ |
| {2} | 2 | 2 | $2^2*2$ |
| {3} | 3 | 3 | $3^2*3$ |
- 分析规模为 2 的子集问题：

| 子集 | 最大值 | 最小值 | 力量值 |
| --- | --- | --- | --- |
| {1, 2} | 2 | 1 | $2^2*1$ |
| {1, 3} | 3 | 1 | $3^2*1$ |
| {2, 3} | 3 | 2 | $3^2*2$ |
- 分析规模为 3 的子集问题：

| 子集 | 最大值 | 最小值 | 力量值 |
| --- | --- | --- | --- |
| {1, 2, 3} | 3 | 1 | $3^2*1$ |

#### 5、如何解决问题

- 手段 1（暴力枚举）：如果枚举所有子集，再求每个子集的力量值，那么时间复杂度会达到非常高的 $O(n·2^n)$，其中有 $2^n$ 种子集（一共有 n 个数字，每个数字有选和不选两种状态），每个子集花费 $O(n)$ 线性扫描最大值和最小值。

至此，问题陷入瓶颈，解决方法是重复以上步骤，枚举掌握的数据结构、算法和技巧寻找思路，突破口在于从另一个角度来理解问题规模（动态规划的思路）。

#### 6、继续观察问题测试用例

同样以数组 nums = [1, 2, 3] 为例：

- 考虑空集的力量值问题：

| 子集 | 最大值 | 最小值 |
| --- | --- | --- |
| {} | 0 | 0 |
- 考虑到「1」为止的力量值问题：

| 子集 | 最大值 | 最小值 |
| --- | --- | --- |
| {} | 0 | 0 |
| {1} | 1 | 1 |
- 考虑到「2」为止的力量值问题：

| 子集 | 最大值 | 最小值 |
| --- | --- | --- |
| {} | 0 | 0 |
| {1} | 1 | 1 |
| {2} | 2 | 2 |
| {1, 2} | 2 | 1 |
- 考虑到「3」为止的力量值问题：

| 子集 | 最大值 | 最小值 |
| --- | --- | --- |
| {} | 0 | 0 |
| {1} | 1 | 1 |
| {2} | 2 | 2 |
| {1, 2} | 2 | 1 |
| {3} | 3 | 3 |
| {1,3} | 3 | 1 |
| {2,3} | 3 | 2 |
| {1,2,3} | 3 | 1 |

这又说明了什么呢？

- **关键点 1 - 递推地构造子集：**

我们发现子集问题可以用递推地方式构造，当我们增加考虑一个新元素时，其实是将已有子集复制一份后，再复制的子集里添加元素。例如我们在考虑「2」时，是将 {} 和 {1} 复制一份后添加再添加元素「2」。

- **关键点 2 - 最大值的贡献：**

由于我们是从小到大增加元素，所以复制后新子集中的最大值一定等于当前元素，那么问题的关键就在「如何计算这些新子集的最小值」。

- **关键点 3 - 最小值的贡献：**

由于我们采用子集复制的方式理解子集构造问题，容易发现数字越早出现，最小值出现次数越大（哆啦 A 梦的翻倍药水）。

例如最初最小值为 1 的子集个数为 1 次，在处理「2」后最小值为 1 的子集个数为 2 次，因此在处理「3」时，就会累加 2 次以 1 为最小值的力量值：$2*(3^2*1)$。同理会累加 1 次以 2 为最小值的力量值：$1*(3*2*2)$，另外还要累加从空集转移而来的 {3}。

至此，问题的解决办法逐渐清晰。

#### 7、解决问题的新手段

- 手段 2（动态规划）：

考虑有 a, b, c, d, e 五个数，按顺序从小到大排列，且从小到大枚举。

当枚举到 d 时，复制增加的新子集包括：

- 以 a 为最小值的子集有 4 个：累加力量值 $4*(d^2*a)$
- 以 b 为最小值的子集有 2 个：累加力量值 $2*(d^2*b)$
- 以 c 为最小值的子集有 1 个：累加力量值 $1*(d^2*c)$

另外还有以 d 本身为最小值的子集 1 个：累加力量值 $1*(d^2*d)$，将 d 左侧元素对结果的贡献即为 s，则有 $pow(d) = d^2*(s + d)$。

继续枚举到 e 是，复制增加的新子集包括：

- 以 a 为最小值的子集有 8 个：累加力量值 $8*(e^2*a)$
- 以 b 为最小值的子集有 4 个：累加力量值 $4*(e^2*b)$
- 以 c 为最小值的子集有 2 个：累加力量值 $2*(e^2*c)$
- 以 d 为最小值的子集有 1个：累加力量值 $1*(e^2*d)$

另外还有以 e 本身为最小值的子集 1 个：累加力量值 $1*(e^2*e)$，将 e 左侧元素对结果的贡献即为 s\`，则有 $pow(e) = e^2*(s` + e)$。

观察 s 和 s` 的关系：

$s = 4*a + 2*b + 1*c$

$s = 8*a + 4*b + 2*c + d = s*2 + d$

这说明，我们可以维护每个元素左侧元素的贡献度 s，并通过 s 来计算当前元素新增的所有子集的力量值，并且时间复杂度只需要 O(1)！

```
[4,3,2,1]
 1 1 2 4
追加 5：
[5,4,3,2,1]
 1 1 2 4 8
```

### 题解（动态规划）

根据问题分析得出的递归公式，使用递推模拟即可，先不考虑大数问题：

```kotlin
class Solution {
    fun sumOfPower(nums: IntArray): Int {
        var ret = 0L
        // 排序
        nums.sort()
        // 影响因子
        var s = 0L
        for (x in nums) {
            ret += (x * x) * (s + x)
            s = s * 2 + x
        }
        return ret.toInt()
    }
}
```

再考虑大数问题：

```kotlin
class Solution {
    fun sumOfPower(nums: IntArray): Int {
        val MOD = 1000000007
        var ret = 0L
        // 排序
        nums.sort()
        // 影响因子
        var s = 0L
        for (x in nums) {
            ret = (ret + (1L * x * x % MOD) * (s + x)) % MOD // x*x 也可能溢出
            s = (s * 2 + x) % MOD
        }
        return ret.toInt()
    }
}
```

实战中我用的是先计算最大影响因子，再累减的写法：

```kotlin
class Solution {
    fun sumOfPower(nums: IntArray): Int {
        val MOD = 1000000007
        var ret = 0L
        val n = nums.size
        // 排序
        nums.sortDescending()
        // 影响因子
        var s = 0L
        var p = 1L
        for (i in 1 until n) {
            s = (s + nums[i] * p) % MOD 
            p = (2 * p) % MOD
        }
        // 枚举子集
        for (i in 0 until n) {
            val x = nums[i]
            ret = (ret + x * x % MOD * (s + x)) % MOD
            if (i < n - 1) {
                s = (s - nums[i + 1]) % MOD
                if (s and 1L != 0L) {
                    s += MOD // 奇数除 2 会丢失精度
                }
                s = (s / 2) % MOD
            }
        }
        return ret.toInt()
    }
}
```

**复杂度分析：**

- 时间复杂度：$O(nlgn)$ 其中 n 为 nums 数组的长度，瓶颈在排序上，计算力量值部分时间复杂度为 O(n)；
- 空间复杂度：$O(lgn)$ 排序递归栈空间。
