## [714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

## 题目描述

给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

## 题目考点

动态规划

## 题解一（动态规划）
 
以卖出视为一笔完整的交易

定义 dp[i][j] 表示在第 i 天完成 j 笔交易的盈利，则有：

- dp[i][j][0] = max{dp[i - 1][j][0], dp[i - 1][j - 1][1] + prices[i]} ：在 [i - 1] 天已经完成 j 次交易且未持有，在 [i - 1] 天已经完成 j - 1 次交易且持有，今日卖出
- dp[i][j][1] = max{dp[i - 1][j][1], dp[i - 1][j][0] - prices[i]} ：在 [i - 1] 天已经完成 j 次交易且持有，在 [i - 1] 天已经完成 j 次交易且未持有，今日买入

在编码技巧上，三维数组可以转为两个二维数组：

- [0] 未持有：sell[i][j] = max{sell[i - 1][j], buy[i - 1][j - 1] + prices[i]}
- [1] 持有：buy[i][j] = max{buy[i - 1][j], sell[i - 1][j] - prices[i]}

- 终止条件：buy[n - 1][1..k] 和 sell[n - 1][1..k] 的所有大小，手续费在最后一天才考虑
- 初始条件：
  - buy[0][0] = -prices[0]、buy[0][1..k] 为非法状态
  - sell[0][0] = 0、sell[0][1..k] 为非法状态

```
class Solution {
    fun maxProfit(prices: IntArray, fee: Int): Int {
        // 最大交易次数
        val maxK = prices.size / 2
        val buy = Array(prices.size) { IntArray(maxK + 1) }.apply {
            this[0][0] = -prices[0]
            for (index in 1..maxK) {
                this[0][index] = Integer.MIN_VALUE / 2
            }
        }
        val sell = Array(prices.size) { IntArray(maxK + 1) }.apply {
            this[0][0] = 0
            for (index in 1..maxK) {
                this[0][index] = Integer.MIN_VALUE / 2
            }
        }
        for (i in 1 until prices.size) {
            for (j in 0..maxK) {
                buy[i][j] = Math.max(buy[i - 1][j], sell[i - 1][j] - prices[i])
                if (j > 0) {
                    sell[i][j] = Math.max(sell[i - 1][j], buy[i - 1][j - 1] + prices[i])
                }
            }
        }
        // 计算手续费
        var result = 0
        for ((day, element) in buy[prices.size - 1].withIndex()) {
            result = Math.max(result, element - fee * day)
        }
        for ((day, element) in sell[prices.size - 1].withIndex()) {
            result = Math.max(result, element - fee * day)
        }
        return result
    }
}
```

**复杂度分析：**

- 时间复杂度：O(n·k)
- 空间复杂度：O(n·k) 超出空间限制


## 题解二（动态规划 + 滚动数组）

```
class Solution {
    fun maxProfit(prices: IntArray, fee: Int): Int {
        // 最大交易次数
        val maxK = prices.size / 2
        val buy = IntArray(maxK + 1).apply {
            this[0] = -prices[0]
            for (index in 1..maxK) {
                this[index] = Integer.MIN_VALUE / 2
            }
        }
        val sell =  IntArray(maxK + 1).apply {
            this[0] = 0
            for (index in 1..maxK) {
                this[index] = Integer.MIN_VALUE / 2
            }
        }
        for (i in 1 until prices.size) {
            for (j in 0..maxK) {
                buy[j] = Math.max(buy[j], sell[j] - prices[i])
                if (j > 0) {
                    sell[j] = Math.max(sell[j], buy[j - 1] + prices[i])
                }
            }
        }
        // 计算手续费
        var result = 0
        for ((day, element) in buy.withIndex()) {
            result = Math.max(result, element - fee * day)
        }
        for ((day, element) in sell.withIndex()) {
            result = Math.max(result, element - fee * day)
        }
        return result
    }
}
```

**复杂度分析：**

- 时间复杂度：O(n·k) 超出时间限制
- 空间复杂度：O(k) 

## 题解三（动态规划 + 在 DP 过程中直接计算手续费）

在前两种题解中，每天都需要花费 O(k) 时间遍历不同的交易次数。我们发现如果直接在 DP 的过程中计算手机费，就不要考虑第三个维度 [k]

```
class Solution {
    fun maxProfit(prices: IntArray, fee: Int): Int {
        val dp = IntArray(2).apply {
            this[0] = 0
            this[1] = -prices[0]
        }
        for (day in 1 until prices.size) {
            dp[0] = Math.max(dp[0], dp[1] + prices[day] - fee)
            dp[1] = Math.max(dp[1], dp[0] - prices[day])
        }
        return Math.max(dp[0], dp[1])
    }
}
```

**复杂度分析：**

- 时间复杂度：O(n)
- 空间复杂度：O(1) 
