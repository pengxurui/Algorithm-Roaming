## [2652. 倍数求和](https://leetcode.cn/problems/sum-multiples/)

## 题目描述

给你一个正整数 n ，请你计算在 [1，n] 范围内能被 3、5、7 整除的所有整数之和。

返回一个整数，用于表示给定范围内所有满足约束条件的数字之和。

### 预备知识 - 容斥原理

定义集合 $A$ 表示能够被 $3$ 整除的数，定义集合 $B$ 表示能够被 $5$ 整除的数，定义集合 $C$ 表示能够被 $7$ 整除的数。如果把这 $3$ 个集合直接加起来，会多出来一些元素重复统计了，因此需要扣除 $A ∩ B$，$A ∩ C$ 和 $B ∩ C$ ，但是又有一小部分元素多扣了，反而再需要加上 A ∩ B ∩ C。这就是 [容斥原理](https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/)：

$$
A ∪ B ∪ C = A + B + C - A ∩ B - A ∩ C - B ∩ C + A ∩ B ∩ C
$$

![](https://pic.leetcode.cn/1682328670-bSskeU-Untitled%202.png){:width=400}

其中：

- $A ∪ B ∪ C$ 表示能够被 $3$ 或 $5$ 或 $7$ 整除的数，也就是原问题的解；
- $A ∩ B$ 表示能够同时被 $3$ 和 $5$ 整除的数；
- $A ∩ C$ 表示能够同时被 $3$ 和 $7$ 整除的数；
- $B ∩ C$ 表示能够同时被 $5$ 和 $7$ 整除的数。

### 预备知识 - 等差数列求和

- 等差数列求和公式：(首项 + 尾项) * 项数 / 2

### 题解一（暴力）

**先思考暴力解法：**

算法：枚举每个数，检查该数字是否为 3 / 5 / 7 的倍数，是则计入结果中。

```kotlin
class Solution {
    fun sumOfMultiples(n: Int): Int {
        var ret = 0
        for (i in 1 .. n) {
            if(i % 3 == 0 || i % 5 == 0 || i % 7 == 0) ret += i
        }
        return ret
    }
}
```

**复杂度分析：**

- 时间复杂度：$O(n)$ 其中 $n$ 为 $nums$ 数组的长度，每个元素最多访问 $1$ 次；
- 空间复杂度：$O(1)$

### 题解二（容斥原理 + 等差数列求和公式）

**暴力解法是否有优化空间呢，先分析重复计算：**

- 要点 1：可以观察到 $[1, n]$ 范围中的目标数是存在关联的，以 $3$ 的倍数为例，$3、6、9、12$ 是以 $3$ 为等差的等差数列，而等差数列的和可以使用公式计算。数字 $m$ 在 $[1, n]$ 范围内中的倍数为 $n / m$ 个，可以使用等差数列求和公式以 $O(1)$ 算出这部分元素之和；
- 要点 2：结合容斥原理，可以在 $O(1)$ 时间复杂度求出原问题。那么能够同时被 $3$ 和 $5$ 整除的等差数列如何计算呢？其实就是计算 $15$ 的倍数。同理能够同时被 $3$ 和 $5$ 和 $7$ 整除的等差数列就是 $105$ 的倍数。

至此，结合容斥原理模拟即可：

```kotlin
class Solution {
    fun sumOfMultiples(n: Int): Int {
        return sum(n, 3) + sum(n, 5) + sum(n, 7) - sum(n, 15) - sum(n, 21) - sum(n, 35) + sum(n, 105)
    }

    private fun sum(n:Int, k:Int) :Int {
        // 等差数列求和公式：(首项 + 尾项) * 项数 / 2
        return (k + (n / k * k)) * (n / k) / 2
    }
}
```

**复杂度分析：**

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

