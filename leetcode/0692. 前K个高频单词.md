## [692. 前K个高频单词](https://leetcode.cn/problems/top-k-frequent-words/description/)

## 题目描述

给定一个单词列表 words 和一个整数 k ，返回前 k 个出现次数最多的单词。

返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率， 按字典顺序 排序。

## 题目考点

排序

## 题解一（桶排序）
 
```
class Solution {
    fun topKFrequent(words: Array<String>, k: Int): List<String> {
        // 桶排序
        var maxFrequency = 0
        val frequencyMap = HashMap<String, Int>()
        for (word in words) {
            frequencyMap[word] = frequencyMap.getOrDefault(word, 0) + 1
            maxFrequency = Math.max(maxFrequency, frequencyMap[word]!!)
        }
        // frequency to List<String>
        val buckets = Array<MutableList<String>?>(maxFrequency + 1) { null }
        for ((word, frequency) in frequencyMap) {
            if (null == buckets[frequency]) {
                buckets[frequency] = LinkedList<String>()
            }
            buckets[frequency]!!.add(word)
        }
        // 输出
        val result = LinkedList<String>()
        for (index in buckets.size - 1 downTo 0) {
            if (result.size >= k) break
            buckets[index]?.let {
                // 题目要求只返回 k 个单词
                val sorted = it.sorted().subList(0, Math.min(it.size, k - result.size))
                result.addAll(sorted)
            }
        }
        return result
    }
}
```

**复杂度分析：**

m 是字符串的种类，l 是字符串的平均长度，n 是单词个数

- 时间复杂度：O(n + ·n·l·klgk) O(n) 是散列表计数和桶排序，单个桶最大的长度是 k，字典排序是 O(n·klgk)
- 空间复杂度：O(n) 

## 题解二（暴力排序）

```
class Solution {
    fun topKFrequent(words: Array<String>, k: Int): List<String> {
        val frequencyMap = HashMap<String, Int>()
        for (word in words) {
            frequencyMap[word] = frequencyMap.getOrDefault(word, 0) + 1
        }
        val resultList = LinkedList<String>().apply {
            for ((word, _) in frequencyMap) {
                add(word)
            }
        }
        // 降序
        resultList.sortWith(Comparator { s1, s2 ->
            if (frequencyMap[s1] != frequencyMap[s2])
                frequencyMap[s2]!! - frequencyMap[s1]!!
            else
                // 字典序
                s1.compareTo(s2)
        })
        return resultList.subList(0, k)
    }
}
```

**复杂度分析：**

- 时间复杂度：O(n + l·m·lgm)
- 空间复杂度：O(n)

## 题解三（快速排序）

```
```

**复杂度分析：**

- 时间复杂度：
- 空间复杂度：

## 题解四（小顶堆）

```
class Solution {

    private val frequencyMap = HashMap<String, Int>()

    fun topKFrequent(words: Array<String>, k: Int): List<String> {
        for (word in words) {
            frequencyMap[word] = frequencyMap.getOrDefault(word, 0) + 1
        }
        // 小顶堆（数组升序）
        val heap = PriorityQueue<String> { s1, s2 ->
            if (frequencyMap[s1] != frequencyMap[s2])
                frequencyMap[s1]!! - frequencyMap[s2]!!
            else
                // 字典序（字典序逆序，最后翻转时就变成正序）
                s2.compareTo(s1)
        }

        for ((element, frequency) in frequencyMap) {
            heap.add(element)
            if (heap.size > k) {
                heap.poll()
            }
        }

        return LinkedList<String>().apply {
            while (!heap.isEmpty()) {
                add(heap.poll())
            }
        }.reversed()
    }
}
```

**复杂度分析：**

- 时间复杂度：O(n + l·mlgk）
- 空间复杂度：O(n + k)
