## [60. 排列序列](https://leetcode.cn/problems/permutation-sequence/description/)

## 题目描述

给你一个链表的头节点 head ，判断链表中是否有环。

## 题目考点

给出集合 [1,2,3,...,n]，其所有元素共有 n! 种排列。

按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：

"123"
"132"
"213"
"231"
"312"
"321"

给定 n 和 k，返回第 k 个排列。

## 题解（阶乘 + 缩小问题规模）

我们定义 [n,k] 问题是：以 [1,...n] 为选择列表的 n! 个全排列中的第 k 个排列

- 方法 1：循环计算下一个排列，直到遇到第 k 个排列

- 方法 2：事实上，我们没有必要计算出所有全排列，则是根据每个分支可能覆盖的排列范围剪枝。例如，在 ”第 1 层“ 中：以 [1 开始的排列有 (n-1)! 个，以 [2 开始的排列有 (n-1)! 个，依次类推

所以，如果 k > (n-1)!，那么 [1 的分支可以剪枝，如果 (n-1)! < k <= 2·(n-1)!，那么可以确定第 0 层的元素是 2。

此时，问题规模缩小为 [n - 1, k - 2·(n-1)!]是：以 [1,3,...n] 为选择列表的 (n-1)! 个全排列中的第 k_i 个排列。

终止条件：n = 0 或 path.length == length，那么已选择路径就是最终结果。

每一层选择的数 a_i = (k - 1) / (n - 1)!，由于 k 是从 1 开始计数，所以需要以 k - 1 计算。

<img width="665" alt="image" src="https://user-images.githubusercontent.com/25008934/210164993-2aced9d3-bb27-4fd0-8273-0c1fb2ecef1b.png">
 
```
class Solution {

    private val factorialMap = HashMap<Int, Int>()

    fun getPermutation(n: Int, k: Int): String {
        // 第 k 个排列
        return StringBuilder().apply {
            getPermutation(n, k, this, BooleanArray(n))
        }.toString()
    }

    private fun getPermutation(n: Int, k: Int, path: StringBuilder, used: BooleanArray) {
        if (n == 0) return
        // 筛选分支（from 0）
        val choice = (k - 1) / factorial(n - 1)
        // 从候选列表中选择第 choice 个数
        var position = 0
        var count = 0
        for (index in used.indices) {
            if (!used[index]) {
                if (++count == choice + 1) {
                    position = index
                    break
                }
            }
        }
        // 选择
        path.append(position + 1)
        used[position] = true
        // 递归（减去被剪枝的分支代表的 k 值）
        getPermutation(n - 1, k - choice * factorial(n - 1), path, used)
        // 不需要回溯
    }

    private fun factorial(n: Int): Int {
        if (n <= 1) return 1
        if (factorialMap.contains(n)) return factorialMap[n]!!
        return (factorial(n - 1) * n).also {
            factorialMap[n] = it
        }
    }
}
```

**复杂度分析：**

- 时间复杂度：O(n)
- 空间复杂度：O(1) 
