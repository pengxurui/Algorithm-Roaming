## [307. 区域和检索 - 数组可修改](https://leetcode.cn/problems/range-sum-query-mutable/description/)

## 题目描述

给你一个数组 nums ，请你完成两类查询。

其中一类查询要求 更新 数组 nums 下标对应的值
另一类查询要求返回数组 nums 中索引 left 和索引 right 之间（ 包含 ）的nums元素的 和 ，其中 left <= right
实现 NumArray 类：

NumArray(int[] nums) 用整数数组 nums 初始化对象
void update(int index, int val) 将 nums[index] 的值 更新 为 val
int sumRange(int left, int right) 返回数组 nums 中索引 left 和索引 right 之间（ 包含 ）的nums元素的 和 （即，nums[left] + nums[left + 1], ..., nums[right]）

## 题目考点

线段树、树状数组

这道题是前缀和的扩展题，总结一下不同题目类型的解决方案：

- 1、静态数组求区间和：前缀和数组
- 2、频繁单点更新，求区间和：树状数组、线段树
- 3、频繁区间更新，求具体位置：差分数组
- 4、频繁区间更新，求区间和：线段树
 
可以看到：虽然线段树能解决的问题域是最大的，但由于线段树的代码量实在时候太多了，我们只有在必要时才考虑线段树。

## 题解一（树状数组）

参考：https://juejin.cn/post/6975808155531870222

显然这道题属于 “2、频繁单点更新求区间和” ，我们优先使用树状数组。

树状数组也叫二叉索引树（Binary Indexed Tree），树状数组核心思想是将数组的元素和按照二进制进行逻辑分层，它平衡的单点修改和区间和查询的时间复杂度：

- 单点更新 add(index,val)：将序列第 index 位元素增加 val，时间复杂度为 O(lgn)，同时对应于在逻辑树形结构上从小分块节点移动到大分块节点的过程（修改元素会影响大分块节点（子节点）的值）；

- 区间查询 prefixSum(index)：查询前 index 个元素的前缀和，时间复杂度为 O(lgn)，同时对应于在逻辑树形结构上累加区间段的过程。

![](https://user-images.githubusercontent.com/25008934/219943135-0d58aa22-ca27-4513-b061-2fe93d560c21.png)

![image](https://user-images.githubusercontent.com/25008934/219945137-72379aea-dfc1-4021-addd-643b8f2f7de3.png)


树状数组的 3 个基本函数：

```
// base 1
int[] tree = new int[n + 1];

// 查询前缀和
int preSum(int x) {
    int ans = 0;
    for (int i = x;i > 0;i -= lowbit(i)) ans += tree[i];
    return ans;
}

// 单点修改（差值）
int add(int index, int delta) {
    for (int i = x; i <= n; i+= lowbit(i)) tree[i] += delta
}

// lowbit
int lowbit(int x) {
    return x & -x;
}
```

首先，我们需要理解树状数组是如何根据 “数组下标的二进制表示” 来存储数组元素的，理解了如何存储自然能理解如何查询：

以 13 为例：13 = 2^3 + 2^2 + 2^0，则 prefixSum(13) = RANGE(1, 8) + RANGE(9, 12) + RANGE(13, 13)，正好可以将区间分为 3 段，且每段的长度正好与 lowbit 对应。

```
arr = [1, 7, 3, 0, 5, 8, 3, 2, 6, 2, 1, 1, 4, 5]
prefixSum(13) = RANGE(1, 8) + RANGE(9, 12) + RANGE(13, 13)
= 29 + 10 + 4 = 43
```

那么，树状数组解决问题的思路就是提前将所有可能出现的 RANGE 计算出来，这样在查询时只需要将每段 RANGE 累加起来，就可以获得某个位置的前缀和。

- 单点更新：当前索引 + 当前块的长度后，可以定位到更大的分块
- 区间和查询：当前索引 - 当前块的长度后，可以定位到更小的分块

其中：“当前块的长度” 就是 lowbit 的数值。

```
class NumArray(val nums: IntArray) {

    private val n = nums.size
    private val tree = IntArray(n + 1)

    init {
        // 建树
        for (index in nums.indices) {
            add(index + 1, nums[index])
        }
    }

    // index：树状数组下标
    private fun add(index: Int, delta: Int) {
        var bit = index
        while (bit <= n) {
            tree[bit] += delta
            bit += lowbit(bit)
        }
    }

    // index：树状数组下标
    private fun preSum(index: Int): Int {
        var sum = 0
        var bit = index
        while (bit > 0) {
            sum += tree[bit]
            bit -= lowbit(bit)
        }
        return sum
    }

    private fun lowbit(x: Int): Int = x and -x

    fun update(index: Int, `val`: Int) {
        add(index + 1, `val` - nums[index])
        nums[index] = `val`
    }

    fun sumRange(left: Int, right: Int): Int {
        return preSum(right + 1) - preSum(left)
    }
}
```

**复杂度分析：**

- 时间复杂度：建树只需要操过 O(nlgn)，单次查询和插入 O(lgn)
- 空间复杂度：O(n) 数组空间 

## 题解二（线段树）

- 思想 1：挑选 O(n) 个特殊区间，使得任意一个区间可以拆分为 O(lgn) 个子特殊区间，其中 O(n) <= 4n；
- 思想 2：Lazy 更新：区间更新没必要修改所有子节点，只需要修改严格处于目标区间中的节点

```
class NumArray(val nums: IntArray) {

    private val tree = SegmentTree(nums.toTypedArray()) { e1: Int?, e2: Int? ->
        if (null == e1) e2!! else if (null == e2) e1 else e1 + e2
    }

    fun update(index: Int, `val`: Int) {
        tree.set(index, `val`)
    }

    fun sumRange(left: Int, right: Int): Int {
        return tree.query(left, right)
    }

    private class SegmentTree<E>(
        // 原始数组
        private val data: Array<E>,
        // 合并函数
        private val merge: (e1: E?, e2: E?) -> E
    ) {

        // 线段树节点（区间范围与区间值）
        private class Node<E>(val left: Int, val right: Int, var value: E)

        // 线段树数组
        private val tree: Array<Node<E>> = Array<Node<E>?>(4 * data.size) { null } as Array<Node<E>>

        // 左子节点的索引
        private val Int.left: Int
            get() = 2 * this + 1

        // 右子节点的索引
        private val Int.right: Int
            get() = 2 * this + 2

        init {
            // 建树
            buildNode(0, 0, data.size - 1)
        }

        // 构建线段树节点
        private fun buildNode(index: Int, left: Int, right: Int) {
            if (left == right) {
                // 叶子节点
                tree[index] = Node(left, right, merge(data[left], null))
                return
            }
            val mid = (left + right) ushr 1
            // 构建左子节点
            buildNode(index.left, left, mid)
            // 构建左子节点
            buildNode(index.right, mid + 1, right)
            // 合并左右子节点
            tree[index] = Node(left, right, merge(tree[index.left].value, tree[index.right].value))
        }

        // 区间查询
        fun query(left: Int, right: Int): E {
            return query(0, left, right)!!
        }

        private fun query(index: Int, left: Int, right: Int): E? {
            // 1、当前节点不处于区间范围内
            if (tree[index].left > right || tree[index].right < left) return null
            // 2、当前节点完全位于区间范围之内
            if (tree[index].left >= left && tree[index].right <= right) {
                return tree[index].value
            }
            // 3、查询左子节点覆盖的区间
            val leftValue = query(index.left, left, right)
            // 4、查询右子节点覆盖的区间
            val rightValue = query(index.right, left, right)
            // 5、合并子节点的结果
            return merge(leftValue, rightValue)
        }

        // 单点更新
        fun set(pos: Int, value: E) {
            set(0, pos, value)
        }

        private fun set(index: Int, pos: Int, value: E) {
            // 1、当前节点不处于区间范围内
            if (tree[index].left > pos || tree[index].right < pos) return
            // 2、叶子节点
            if (tree[index].left == pos && tree[index].right == pos) {
                tree[index].value = value
                return
            }
            // 3、更新左子树
            set(index.left, pos, value)
            // 4、更新右子树
            set(index.right, pos, value)
            // 5、合并子节点的结果
            tree[index].value = merge(tree[index.left].value, tree[index.right].value)
        }
    }
}

/**
 * Your NumArray object will be instantiated and called as such:
 * var obj = NumArray(nums)
 * obj.update(index,`val`)
 * var param_2 = obj.sumRange(left,right)
 */
```

查询：[3,7] = [3,3] + [4,5] + [6,7]

![](https://user-images.githubusercontent.com/25008934/219953065-e9ee44bf-5467-4421-9854-1e1440b1e3a6.png)

Lazy 懒更新：

区间更新没必要修改所有子节点，只需要修改严格处于目标区间中的节点，例如修改 [1,7] 只需要修改 [1,5] 与 [6,7]，而不需要继续递归。

- 使用 Lazy 数组记录区间未更新的值
- 查询区间和时，需要在节点记录的区间和的基础上 + 区间长度 * Lazy[index]
- 如果将来新的更新破坏了原有 Lazy 数组的记录，我们需要将 Lazy 传递到左右子节点

![](https://user-images.githubusercontent.com/25008934/219954006-b4a0267b-fed8-4377-ae30-90253ef4cc65.png)

为什么线段树数组的长度要设置为 4n？

![](https://user-images.githubusercontent.com/25008934/219952262-4e511634-8c6a-4164-9e40-7a4c176f643a.png)

当我们将数组扩展为二叉树后，最后一行的叶子节点个数为 n`，而整棵树的节点个数是 2*n`。但这个 n` 并不是原始数组的 n，为了保证在满二叉树时能够容纳所有叶子节点，我们直接设置 n` 为 2n，整棵树的节点总数就是 4n。

例如，在这幅图中，满二叉树时最后一行最后一个节点是 31，如果 n` 取 n（25）即无法满足，而 n` 取 2n（50）就可以满足。

简化版（参考：https://leetcode.cn/problems/range-sum-query-mutable/solutions/352318/xian-duan-shu-zu-shou-hui-tu-xiang-yi-qing-er-chu-/）

```
class NumArray(private val nums: IntArray) {

    private val n = nums.size

    // 线段树数组
    private val tree = IntArray(2 * n)

    init {
        // 建树
        // 先将叶子节点设置在末位 n 个位置
        for (index in n until 2 * n) {
            tree[index] = nums[index - n]
        }
        // 循环设置父节点
        for (index in n - 1 downTo 0) {
            tree[index] = tree[index * 2] + tree[index * 2 + 1]
        }
    }

    // 偶数下标是左节点，奇数下标是右节点
    fun update(index: Int, `val`: Int) {
        // 先更新叶子节点，再循环更新父节点
        var treeIndex = index + n
        tree[treeIndex] = `val`
        while (treeIndex > 0) {
            // 当前左右节点的下标
            val left = if (0 == treeIndex % 2) treeIndex else treeIndex - 1
            val right = if (0 == treeIndex % 2) treeIndex + 1 else treeIndex
            // 更新父节点
            tree[treeIndex / 2] = tree[left] + tree[right]
            // 定位父节点
            treeIndex /= 2
        }
        // 修改原始数组
        nums[index] = `val`
    }

    fun sumRange(left: Int, right: Int): Int {
        // 寻找能够代表当前区间的父节点
        var sum = 0
        var leftIndex = left + n
        var rightIndex = right + n
        while (leftIndex <= rightIndex) {
            if (0 != leftIndex % 2) {
                // 左端点指向右节点，需要单独计算
                sum += tree[leftIndex++]
                continue
            }
            if (0 == rightIndex % 2) {
                // 右端点指向左节点，需要单独计算
                sum += tree[rightIndex--]
                continue
            }
            // 寻找父节点
            leftIndex /= 2
            rightIndex /= 2
        }
        return sum
    }
}

/**
 * Your NumArray object will be instantiated and called as such:
 * var obj = NumArray(nums)
 * obj.update(index,`val`)
 * var param_2 = obj.sumRange(left,right)
 */
```

**复杂度分析：**

- 时间复杂度：O(n)
- 空间复杂度：O(n) 
