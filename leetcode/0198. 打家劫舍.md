## [198. 打家劫舍](https://leetcode.cn/problems/house-robber/description/)

## 题目描述

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

## 题目考点

动态规划

## 题解（动态规划）
 
```
class Solution {
    fun rob(nums: IntArray): Int {
        // dp[i] 表示以 [i] 为止可以获取的最高金额
        val n = nums.size
        val dp = IntArray(n + 1)
        for (i in 1..n) {
            // dp[i - 1]：只考虑 [i - 1] 之前的方案
            // nums[i - 1] 只考虑当前位置的方案，即只有一个房屋的情况
            // nums[i - 1] + dp[i - 2] 考虑当前位置加 [i - 2] 的最高金额的情况
            dp[i] = Math.max(dp[i - 1], nums[i - 1])
            if (i >= 2) dp[i] = Math.max(dp[i], nums[i - 1] + dp[i - 2])
        }
        return dp[n]
    }
}
```

滚动数组：

```
class Solution {
    fun rob(nums: IntArray): Int {
        // dp[i] 表示以 [i] 为止可以获取的最高金额
        val n = nums.size
        var first = 0
        var second = 0
        for (i in 1..n) {
            // dp[i - 1]：只考虑 [i - 1] 之前的方案
            // nums[i - 1] 只考虑当前位置的方案，即只有一个房屋的情况
            // nums[i - 1] + dp[i - 2] 考虑当前位置加 [i - 2] 的最高金额的情况
            var cur = Math.max(second, nums[i - 1])
            if (i >= 2) cur = Math.max(cur, nums[i - 1] + first)
            first = second
            second = cur
        }
        return second
    }
}
```

**复杂度分析：**

- 时间复杂度：O(n)
- 空间复杂度：O(1) 
