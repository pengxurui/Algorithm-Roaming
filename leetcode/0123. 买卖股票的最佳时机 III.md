## [123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

## 题目描述

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

## 题目考点

动态规划

## 题解（动态规划）

这道题可以交易两次，因此在 [j] 维度需要从 2 个状态变成 5 个状态：0 -> buy1 -> sell1 -> buy2 -> sell2

- 0：未进行过任何操作；
- 1(buy1)：只进行过一次买操作；
- 2(sell1)：进行了一次买操作和一次卖操作，即完成了一笔交易；
- 3(buy2)：在完成了一笔交易的前提下，进行了第二次买操作；
- 4(sell2)：完成了全部两笔交易。

由于状态 0 永远是 0，所以可以不进行记录。对于其他状态的转移方程是：

- dp[i][buy1] = max{dp[i - 1][buy1], -prices[i]} ：在 [i - 1][buy1] 的状态保持不变，或者在 [i - 1][0] 的状态下买入
- dp[i][sell1] = max{dp[i - 1][sell1], dp[i - 1][buy1] + prices[i]}：在 [i - 1][sell1] 的状态保持不变，或者在 [i - 1][buy1] 的状态下卖出
- dp[i][buy2] = max{dp[i - 1][buy2], dp[i - 1][sell1] - prices[i]}
- dp[i][sell2] = max{dp[i - 1][sell2], dp[i - 1][buy2] + prices[i]}

因为无论题目中是否允许「在同一天买入并且卖出」这一操作，最终的答案都不会受到影响，这是因为这一操作带来的收益为零。所以在编码上，
我们可以将  dp[i][sell1] = max{dp[i - 1][sell1], dp[i - 1][buy1] + prices[i]} 替换为  dp[i][sell1] = max{dp[i - 1][sell1], dp[i][buy1] + prices[i]}

例如：在计算 dp[i][buy1] 比 dp[i - 1][buy1] 多考虑了一种在 [i] 当天买入的情况，而随后在计算 dp[i][sell1] 后又将当天买入的股票卖出，对结果没有影响。

所以 dp[i - 1][buy1] 替换为 dp[i][buy1] 结果不变。

```
class Solution {
    fun maxProfit(prices: IntArray): Int {
        // 动态规划 + 滚动数组
        val dp = IntArray(4).apply {
            this[0] = -prices[0]
            this[2] = -prices[0]
        }
        for (index in 1 until prices.size) {
            dp[0] = Math.max(dp[0], 0 - prices[index])
            dp[1] = Math.max(dp[1], dp[0] + prices[index])
            dp[2] = Math.max(dp[2], dp[1] - prices[index])
            dp[3] = Math.max(dp[3], dp[2] + prices[index])
        }
        return dp[3]
    }
}
```

**复杂度分析：**

- 时间复杂度：O(n)
- 空间复杂度：O(1) 
