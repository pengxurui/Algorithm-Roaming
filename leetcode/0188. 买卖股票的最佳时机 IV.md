## [188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/)

## 题目描述

给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

## 题目考点

动态规划

## 题解一（动态规划）

一次交易应该以完成一次卖出操作计量。

在 k = 2 题目的基础上，我们需要扩展 [j] 的状态：

我们定义两个 dp 数组 buy[i][j] 和 sell[i][j] 表示第 i 天结束后进行了 j 次交易后，分别处于持有和未持有状态的盈利。则有状态转移方程：

- buy[i][j] = max{buy[i - 1][j], sell[i - 1][j] - prices[i]}。其中第二项是在第 [i - 1] 天完成 j 次交易后，在第 [i] 天进行买入操作（未卖出）
- sell[i][j] = max{sell[i - 1][j], buy[i - 1][j - 1] + prices[j]} 。其中第二项是在第 [i - 1] 天完成 j - 1 次交易后，在第 [i] 天完成第 j 次交易

- 终止条件：在最后一天，不持有的利润一定大于持有的利润，所以结果一定在 sell 数组中。但是卖出次数越多不一定是最优解，所以需要在 sell[n-1[0..k] 中遍历最优解
- 初始状态：我们需要将所有的 buy[0][0..k] 和 sell[0][0..k] 设置为边界条件：
  - buy[0][0] 表示在第 0 天完买入：-prices[0]
  - buy[0][1..k] 是非法的状态：Integer.MIN_VALUE / 2
  - sell[0][0] 表示不进行任何操作：0
  - sell[0][1..k] 是非法的状态：Integer.MIN_VALUE / 2

```
class Solution {
    fun maxProfit(k: Int, prices: IntArray): Int {
        val availableK = Math.min(k, prices.size / 2)
        val buy = Array(prices.size) { IntArray(availableK + 1) }.apply {
            this[0][0] = -prices[0]
            for (index in 1..availableK) {
                this[0][index] = Integer.MIN_VALUE / 2
            }
        }
        val sell = Array(prices.size) { IntArray(availableK + 1) }.apply {
            this[0][0] = 0
            for (index in 1..availableK) {
                this[0][index] = Integer.MIN_VALUE / 2
            }
        }
        for (i in 1 until prices.size) {
            for (j in 0..availableK) {
                buy[i][j] = Math.max(buy[i - 1][j], sell[i - 1][j] - prices[i])
                if (j > 0) {
                    // sell[0] 永远是 0
                    sell[i][j] = Math.max(sell[i - 1][j], buy[i - 1][j - 1] + prices[i])
                }
            }
        }
        var result = 0
        for (element in sell[prices.size - 1]) {
            result = Math.max(result, element)
        }
        return result
    }
}
```

**复杂度分析：**

- 时间复杂度：O(n·availableK)
- 空间复杂度：O(n·availableK) 

## 题解二（动态规划 + 滚动数组）

```
class Solution {
    fun maxProfit(k: Int, prices: IntArray): Int {
        val availableK = Math.min(k, prices.size / 2)
        val buy = IntArray(availableK + 1).apply {
            this[0] = -prices[0]
            for (index in 1 until size) {
                this[index] = Integer.MIN_VALUE / 2
            }
        }
        val sell = IntArray(availableK + 1).apply {
            this[0] = 0
            for (index in 1 until size) {
                // 取最小的整数会溢出
                this[index] = Integer.MIN_VALUE / 2
            }
        }
        for (i in 1 until prices.size) {
            for (j in 0..availableK) {
                buy[j] = Math.max(buy[j], sell[j] - prices[i])
                if (j > 0) {
                    // sell[0] 永远是 0
                    sell[j] = Math.max(sell[j], buy[j - 1] + prices[i])
                }
            }
        }
        var result = 0
        for (element in sell) {
            result = Math.max(result, element)
        }
        return result
    }
}
```

**复杂度分析：**

- 时间复杂度：O(n·availableK)
- 空间复杂度：O(availableK) 

## 题解三（wqs 二分）TODO

```
```

**复杂度分析：**

- 时间复杂度：O(n·lgn)
- 空间复杂度：O(1) 

