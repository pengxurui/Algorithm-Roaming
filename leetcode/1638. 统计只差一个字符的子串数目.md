## [1638. 统计只差一个字符的子串数目](https://leetcode.cn/problems/count-substrings-that-differ-by-one-character/description/)

## 题目描述

给你两个字符串 s 和 t ，请你找出 s 中的非空子串的数目，这些子串满足替换 一个不同字符 以后，是 t 串的子串。换言之，请你找到 s 和 t 串中 恰好 只有一个字符不同的子字符串对的数目。

比方说， "computer" 和 "computation" 加粗部分只有一个字符不同： 'e'/'a' ，所以这一对子字符串会给答案加 1 。

请你返回满足上述条件的不同子字符串对数目。

一个 子字符串 是一个字符串中连续的字符。

## 题目考点

字符串、动态规划

## 题解一（暴力枚举）

枚举所有的子串：以 [i..] 和 [j..] 为起点。

```
class Solution {
    fun countSubstrings(s: String, t: String): Int {
        // 方法：暴力枚举
        var result = 0
        for (indexS in s.indices) {
            for (indexT in t.indices) {
                var diffCount = 0
                var offset = 0
                while (indexS + offset < s.length && indexT + offset < t.length) {
                    if (s[indexS + offset] != t[indexT + offset]) diffCount++
                    if (diffCount == 1) result++
                    if (diffCount >= 2) break
                    offset++
                }
            }
        }
        return result
    }
}
```

**复杂度分析：**

- 时间复杂度：O(m·n·min(m,n))
- 空间复杂度：O(1) 

我们发现内层循环存在重复计算，且目标组合一定是两个相同长度的子串，所以我们使用滑动窗口。

但是在本题中：每次移动窗口后不仅左右端点变化，而且中间所有元素的映射关系也变化，所以滑动窗口法不可行。

## 题解二（动态规划）

定义 dp[i][j] 表示以 [i] 和 [j] 结尾的字符串中目标答案的个数，那么 dp[i + 1][j + 1] 有：

- 如果 s[i] == s[j]，那么 dp[i + 1][j + 1] = dp[i][j]
- 如果 s[i] != s[j]，由于 [i] 和 [j] 已经占用一次不相同计数，所以 dp[i + 1][j + 1] = 就是 s[0..i] 和 t[0..j] 的最长公共后缀的长度 + 1（+ 1 是只不取前面的公共后缀）



```
```

**复杂度分析：**

- 时间复杂度：O(m·n)
- 空间复杂度：O(1) 

## 题解三（中心扩散法）



```
```

**复杂度分析：**

- 时间复杂度：O(m·n)
- 空间复杂度：O(1) 
