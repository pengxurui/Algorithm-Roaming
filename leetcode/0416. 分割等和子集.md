## [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/description/)
## [剑指 Offer II 101. 分割等和子集](https://leetcode.cn/problems/NUPfPr/?favorite=e8X3pBZi)

## 题目描述

给定一个非空的正整数数组 nums ，请判断能否将这些数字分成元素和相等的两部分。

## 题目考点



## 题解一（排序 · 错误）
 
```
class Solution {
    fun canPartition(nums: IntArray): Boolean {
        val fullSum = nums.sum()
        val target = fullSum / 2
        // 不能整除
        if (target * 2 != fullSum) return false
        // 排序
        nums.sort()
        // 游标
        var index = 0
        var leftSum = 0
        var rightSum = fullSum
        //  && index < nums.size
        while (leftSum < rightSum) {
            leftSum += nums[index]
            rightSum -= nums[index]
            index++
            if (leftSum == rightSum) return true
        }
        return false
    }
}
```

case ：[2,2,1,1]

## 题解二（枚举子集 · 错误）

错误：子序列可以是非连续的

```
class Solution {
    fun canPartition(nums: IntArray): Boolean {
        val fullSum = nums.sum()
        println(fullSum)
        // 不能整除
        if (fullSum / 2 * 2 != fullSum) return false
        // 枚举子集
        for (start in 0 until nums.size) {
            var curSum = 0
            for (index in start until nums.size) {
                curSum += nums[index]
                if (curSum * 2 == fullSum) return true
            }
        }
        return false
    }
}
```

## 题解三（回溯 + 组合）

剪枝：当一个分割方法出现的 targetSum 无法满足时，将来遇到相同 targetSum 时一定无法满足:

例如: [11,3,8,1] 问题中，[3,8] 路径与 [11] 路径等价，因此可以被过滤。

```
class Solution {

    private val badSumMemo = HashSet<Int>()

    fun canPartition(nums: IntArray): Boolean {
        val fullSum = nums.sum()
        // 不能整除
        if (fullSum / 2 * 2 != fullSum) return false
        return canPartitionBackTrack(nums, 0, fullSum / 2)
    }

    private fun canPartitionBackTrack(nums: IntArray,index : Int, targetSum: Int): Boolean {
        if (targetSum == 0) return true
        if (targetSum < 0) return false
        if (badSumMemo.contains(targetSum)) return false
        for (index in index until nums.size) {
            // 递归
            if (canPartitionBackTrack(nums, index + 1, targetSum - nums[index])) return true
            // 记录
            badSumMemo.add(targetSum - nums[index])
        }
        return false
    }
}
```

**复杂度分析：**

- 时间复杂度：O(C(n,n))
- 空间复杂度：O(n) 

## 题解四（动态规划 · 0-1 背包问题 · TODO）

从 n 个物品中选择 x 个后得到目标或者价值最大

- 0-1 背包问题：每个物品最多只能选择 1 次
- 完全背包问题：每个物品可以选择无限次

```
```

**复杂度分析：**

- 时间复杂度：O(n!)
- 空间复杂度：O(n) 
