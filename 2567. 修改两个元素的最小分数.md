## [2567. 修改两个元素的最小分数](https://leetcode.cn/problems/minimum-score-by-changing-two-elements/)

## 题目描述

给你一个下标从 0 开始的整数数组 nums 。

nums 的 最小 得分是满足 0 <= i < j < nums.length 的 |nums[i] - nums[j]| 的最小值。
nums的 最大 得分是满足 0 <= i < j < nums.length 的 |nums[i] - nums[j]| 的最大值。
nums 的分数是 最大 得分与 最小 得分的和。
我们的目标是最小化 nums 的分数。你 最多 可以修改 nums 中 2 个元素的值。

请你返回修改 nums 中 至多两个 元素的值后，可以得到的 最小分数 。

|x| 表示 x 的绝对值。

## 题目考点

排序、枚举、滑动窗口

### 题解（排序 + 枚举）

这道题也有脑筋急转弯的成分，同时我们可以扩展思考下 “最多修改 k 个元素的最小得分” 问题，最后再说。

这道题的关键在于得分的定义：

- “最小得分” 表示任意数组中两个数字之间的最小绝对差；
- “最大得分” 表示任意数组中两个数字之间的最大绝对差。

理解题意后容易发现：

- 影响 “最小得分” 的是数组中最接近的两个数字。当数组中存在两个相同元素时，“最小得分” 可以取到最小值 0；
- 影响 “最大得分” 的是数组中最不接近的两个数，即最大值和最小值。当我们将最大值和最小值修改为数组中间的某个元素时，能使得差值变小的同时，保持 “最小得分” 取最小值 0。

因此得知： **这道题的关键点在于修改数组的最大值或最小值成为数组中间的某个元素。** 要么让最大值变小，要么让最小值变大。由于题目最多只能修改 2 次，因此最多只能以下 3 种情况：

- 情况 1：修改数组中最大的两个数为 `nums[n - 3]`；
- 情况 2：修改数组中最小的两个数为 `nums[2]`；
- 情况 3：修改数组的最大值为 `nums[n - 1]`，修改数组的最小值为 `nums[1]`。

简单枚举出 3 种情况的解后再进行一轮比较即可。

最后再观察边界条件，数组的最小长度为 3，所以不需要特判。

```kotlin
class Solution {
    fun minimizeSum(nums: IntArray): Int {
        nums.sort()
        val n = nums.size
        val choice1 = nums[n - 3] - nums[0]
        val choice2 = nums[n - 1] - nums[2]
        val choice3 = nums[n - 2] - nums[1]
        return Math.min(choice1, Math.min(choice2, choice3))
    }
}
```

**复杂度分析：**

- 时间复杂度：$O(nlgn)$ 快速排序占用的时间，如果手动维护最小的 3 个元素和最大的 3 个元素可以降低到 $O(n)$ 时间复杂度；
- 空间复杂度：$O(lgn)$ 排序占用的递归栈空间。

再扩展思考一下，如果题目说明最多可以修改 $k （0 ≤ k ≤ nums.length）$次的话，应该解决问题呢？ —— 即 “求最多修改 k 个元素的最小得分”，原题就是 k = 2 的情况。

那么这道题就是考察 **“滑动窗口”** 技巧了，我们可以将修改的范围视为一个跨越数组首尾且长度为 k 的滑动窗口，那么而问题的答案就取决于 “不被” 滑动窗口包围的另一部分。再逆向思考一下，我们可以用长度为 `length - k` 的滑动窗口在数组上移动，并记录窗口首尾元素的差值，枚举所有情况后记录最小值即为最小得分：

举个例子，在输入数组为 `[1, 4, 5, 7, 8] ，k = 2` 时，前文提到的 3 种方案分别对应以下 3 个窗口状态：

- 情况 1：修改数组中最大的两个数：`1,4 | 5,7,8 |`
- 情况 2：修改数组中最小的两个数：`| 1,4,5 | 7,8`
- 情况 3：修改数组的最大值和最小值：`1 | 4,5,7 | 8`

```kotlin
class Solution {
    fun minimizeSum(nums: IntArray): Int {
        val n = nums.size
        // 操作次数
        val k = 2
        // 滑动窗口
        val len = n - k
        nums.sort()
        var min = Integer.MAX_VALUE
        for (left in 0..n - len) {
            val right = left + len - 1
            min = Math.min(min, nums[right] - nums[left])
        }
        return min
    }
}
```

**复杂度分析同上。**
