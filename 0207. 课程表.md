## [207. 课程表](https://leetcode.cn/problems/course-schedule/description/)

## 题目描述

你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。

例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。
请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。

## 题目考点

图、拓扑排序

## 题解一（领接表 + Kahn 拓扑排序）
 
给定一个包含 n 个节点的有向图 G，我们给出它的节点编号的一种排列，如果满足：

```
对于图 G 中的任意一条有向边 (u,v)，u 在排列中都出现在 v 的前面。
```

那么称该排列是图 G 的「拓扑排序」。

**拓扑排序的基本性质：**

- 如果图存在环，则一定不存在拓扑排序
- 拓扑排序是不唯一的， 例如 n 个节点间没有任何边，则任何排列都是拓扑排序

**有了上述的简单分析，我们就可以将本题建模成一个求拓扑排序的问题了：**

我们将每一门课看成一个节点：
如果想要学习课程 A 之前必须完成课程 B，那么我们从 B 到 A 连接一条有向边。这样以来，在拓扑排序中，B 一定出现在 A 的前面。最后求出该图是否存在拓扑排序，使用拓扑排序判断图是否有环

![image](https://user-images.githubusercontent.com/25008934/227141452-3908530c-0fcf-4254-8033-a54a82051eff.png)

**拓扑排序的思路：**

每一次从图中删除没有前驱的节点（入度为 0），并修改它指向的节点的入度。如果图中没有入度为 0 的节点，必然存在环，即无法完成拓扑排序。
 
```
class Solution {

    fun canFinish(numCourses: Int, prerequisites: Array<IntArray>): Boolean {
        // 入度表
        val inDegrees = IntArray(numCourses)
        // 邻接表
        val graph = HashMap<Int, MutableList<Int>>()
        // 队列
        val queue = LinkedList<Int>()
        // 计数
        var finishCnt = 0
        for (prerequisite in prerequisites) {
            graph.getOrPut(prerequisite[1]) { LinkedList<Int>() }.add(prerequisite[0])
            inDegrees[prerequisite[0]]++
        }
        // 拓扑排序：
        // 将入度为 0 的节点入队
        for (index in inDegrees.indices) {
            if (inDegrees[index] == 0) queue.offer(index)
        }
        while (!queue.isEmpty()) {
            // 删除入度为 0 的节点
            val node = queue.poll()
            // 修改相邻节点
            for (edge in graph[node] ?: Collections.emptyList()) {
                if (--inDegrees[edge] == 0) queue.offer(edge)
            }
            finishCnt++
        }
        println("finsiCnt=$finishCnt")
        return finishCnt == numCourses
    }
}
```

**复杂度分析：**

- 时间复杂度：O(n+m)
- 空间复杂度：O(n+m) 

## 题解二（领接表 + DFS）

使用 DFS 判断图是否有环：

对于图中的任意一个节点，它在搜索的过程中有三种状态，即：

「未搜索」：我们还没有搜索到这个节点；

「搜索中」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成）；

「已完成」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求。

在每一轮的搜索搜索开始时，我们任取一个「未搜索」的节点开始进行深度优先搜索。

我们将当前搜索的节点 u 标记为「搜索中」，遍历该节点的每一个相邻节点 v：

如果 v 为「未搜索」，那么我们开始搜索 v，待搜索完成回溯到 u；

如果 v 为「搜索中」，那么我们就找到了图中的一个环，因此是不存在拓扑排序的；

如果 v 为「已完成」，那么说明 v 已经在栈中了，而 u 还不在栈中，因此 u 无论何时入栈都不会影响到 (u,v) 之前的拓扑关系，以及不用进行任何操作。

当 u 的所有相邻节点都为「已完成」时，我们将 u 放入栈中，并将其标记为「已完成」。 **因为它没有更多前驱节点，已经是目前链路的最早节点。**

在整个深度优先搜索的过程结束后，如果我们没有找到图中的环，那么栈中存储这所有的 n 个节点，从栈顶到栈底的顺序即为一种拓扑排序。

参考：https://leetcode.cn/problems/course-schedule/solutions/359392/ke-cheng-biao-by-leetcode-solution/

参考：https://leetcode.cn/problems/course-schedule/solutions/8383/tuo-bu-pai-xu-by-liweiwei1419/

```
class Solution {

    fun canFinish(numCourses: Int, prerequisites: Array<IntArray>): Boolean {
        // 领接表
        val graph = HashMap<Int, LinkedList<Int>>().apply {
            for (prerequisite in prerequisites) {
                this.getOrPut(prerequisite[0]) { LinkedList<Int>() }.add(prerequisite[1])
            }
        }
        // 0：未搜索、1：搜索中、2：已完成
        val flags = IntArray(numCourses)
        // DFS
        for (index in flags.indices) {
            if (0 == flags[index]) {
                if (!dfs(graph, flags, index)) return false
            }
        }
        return true
    }

    private fun dfs(graph: Map<Int, List<Int>>, flags: IntArray, index: Int): Boolean {
        // 标记搜索中
        flags[index] = 1
        for (edge in graph[index] ?: Collections.emptyList()) {
            // 成环
            if (flags[edge] == 1) return false
            if (flags[edge] == 2) continue
            // 递归
            if (!dfs(graph, flags, edge)) return false
        }
        // 标记已完成
        flags[index] = 2
        return true
    }
}
```

**复杂度分析：**

- 时间复杂度：O(n+m)
- 空间复杂度：O(n+m) 
