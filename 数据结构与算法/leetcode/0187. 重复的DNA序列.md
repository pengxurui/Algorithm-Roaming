## [187. 重复的DNA序列](https://leetcode.cn/problems/repeated-dna-sequences/description/)

## 题解一（滑动窗口 + 哈希表）

```
class Solution {
    fun findRepeatedDnaSequences(s: String): List<String> {
        if (s.length <= 10) return Collections.emptyList()
        val n = s.length
        val map = HashMap<String, Int>()
        val ret = LinkedList<String>()
        for (i in 0 .. n - 10) {
            val key = s.substring(i, i + 10)
            map[key] = map.getOrDefault(key, 0) + 1
            // 仅在计数为 2 时记录结果，就不需要使用散列表去重
            if (map[key]!! == 2) ret.add(key)
        }
        return ret
    }
}
```

- O(nC) C=10
- O(nC)

## 题解二（滑动窗口 + 哈希表 + 滚动哈希）

使用 String 作为 Key 会重复计算散列值，我们可以使用滚动哈希优化哈希计算，同时使用 Int 代替 String 作为散列表的 Key（否则在查询时还会计算哈希）

如何维护长度为 10 的子串哈希：

- 注意到字符集只有 4 个字符，我们可以用 2 位二进制分别表示 ATGC 4 个字符:00、01、10、11
- 那么，10 个字符需要的哈希为 20 位
- 最后，使用滑动窗口维护

```
class Solution {
    fun findRepeatedDnaSequences(s: String): List<String> {
        if (s.length <= 10) return Collections.emptyList()
        val n = s.length
        val map = HashMap<Int, Int>()
        val ret = LinkedList<String>()
        // 字符集
        val charHash = mapOf('A' to 0, 'C' to 1, 'G' to 2, 'T' to 3)
        // 有效位掩码
        val mask = 1.shl(20) - 1
        var hash = 0
        for (i in 0 until n) {
            // 推入
            hash = hash.shl(2) + charHash[s[i]]!!
            // 推出
            if (i > 9) hash = hash.and(mask)
            // 记录
            if (i >= 9) {
                map[hash] = map.getOrDefault(hash, 0) + 1
                if (map[hash]!! == 2) ret.add(s.substring(i - 9, i + 1))
            }
        }
        return ret
    }
}
```

- O(n)
- O(n)

## 题解三（多项式哈希）

- 系数越大，质数，冲突概率更小
- 值域 · 系数决定冲突概率

```
class Solution {
    fun findRepeatedDnaSequences(s: String): List<String> {
        if (s.length <= 10) return Collections.emptyList()
        val n = s.length
        val map = HashMap<Int, Int>()
        val ret = LinkedList<String>()
        // 预处理多项式系数
        val k0= 131313
        var k9 = 1
        repeat(9) {
            k9 *= k0
        }
        var hash = 0
        for (i in 0 until n) {
            // 推出
            if (i > 9) hash -= k9 * s[i - 10].toInt()
            // 推入
            hash = hash * k0 + s[i].toInt()
            // 记录
            if (i >= 9) {
                map[hash] = map.getOrDefault(hash, 0) + 1
                if (map[hash]!! == 2) ret.add(s.substring(i - 9, i + 1))
            }
        }
        return ret
    }
}
```

- O(n)
- O(n)
