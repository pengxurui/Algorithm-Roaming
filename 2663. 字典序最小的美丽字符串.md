## [2663. 字典序最小的美丽字符串](https://leetcode.cn/problems/lexicographically-smallest-beautiful-string/)

## 题目描述

如果一个字符串满足以下条件，则称其为 美丽字符串 ：

它由英语小写字母表的前 k 个字母组成。
它不包含任何长度为 2 或更长的回文子字符串。
给你一个长度为 n 的美丽字符串 s 和一个正整数 k 。

请你找出并返回一个长度为 n 的美丽字符串，该字符串还满足：在字典序大于 s 的所有美丽字符串中字典序最小。如果不存在这样的字符串，则返回一个空字符串。

对于长度相同的两个字符串 a 和 b ，如果字符串 a 在与字符串 b 不同的第一个位置上的字符字典序更大，则字符串 a 的字典序大于字符串 b 。

例如，"abcd" 的字典序比 "abcc" 更大，因为在不同的第一个位置（第四个字符）上 d 的字典序大于 c 。

## 问题结构化

![](https://pic.leetcode.cn/1683352797-nnCbcT-2663.jpg){:width=400}

#### 1、概括问题目标

构造一个满足条件的目标字符串，命名为「美丽字符串」。

#### 2、分析问题要件

- 字符集：题目要求目标字符串仅能使用小写字母表的前 k 个字母，例如 k = 4 只能使用 {a, b, c, d}；
- 美丽字符串（限制回文）：题目要求目标字符串不包含长度大于 1 的回文子串；
- 字典序更大：题目要求目标字符串的字典序大于字符串 s；
- 字典序最小：题目要求返回字典序最小的方案；

#### 3、观察数据特征

- 数据量：数据量的上界是 10^5，这要求算法的时间复杂度不能高于 O(n^2)；
- 输入字符串 s 本身就是「美丽字符串」。

#### 4、观察测试用例

以 s = “abcz”, k = 26 为例：

- 修改 ‘z’：无法修改 ’z’ 获得字典序更高的字母；
- 修改 ‘c’：可以修改 ‘c’ 为 ’d’ 得到 “abdz”，且构成「美丽字符串」；
- 修改 ‘a’ 或 ’b’：也可以构造「美丽字符串」，但字典序不会优于 “abdz”。

#### 5、提高抽象程度

- 权重：字典序的规则中，字符串越靠前的位置对排序的影响权重越大，例如序列 ”ba“ 的字典序大于 ”az“；
- 提升：为了构造字典序更大的「美丽字符串」，我们需要将字符串中的某个字母修改为字母序更大的字母，例如将 ‘a’ 提升到 ‘b’ 或 ‘z’；
- 下一个排列：题目要求目标字符串的字典序大于字符串 s，又是所有方案中字典序最小的，问题模型类似经典题目「[31. 下一个排列](https://leetcode.cn/problems/next-permutation/)」，可以借鉴；
- 是否为决策问题：由于每次提升操作有多种位置选择，因此这是个决策问题，准确来说是一个构造问题。
- 总结：这是一个构造问题，要求构造满足条件的「下一个美丽字符串」。

#### 6、具体化解决手段

**如何构造满足条件的「下一个美丽字符串」？**

由于题目要求构造字典序最小的方案，那么将 s[i] 提升为字母序更大的下一个字母是最优的，例如将 ’a’ 提升到 ‘b’ 优于提升到 ‘z’。除非在 s[i] 已经是字典序最大的字母 ‘z’ 时，我们需要提升它的前一个字母 s[i - 1]，例如将 ”az“ 提升为 ”bz“ 优于 “cz”。

**构造「下一个美丽字符串」需要提升字母序，那么如何决策替换策略？**

由于字符串中越靠前的位置的权重越高，容易想到的贪心策略是从后往前提升字符。如果提升 s[n - 1] 能够构造「美丽字符串」，那么直接提升 s[n - 1] 即可，否则需要提升更靠前的 s[n - 2]。

当我们确定提升 s[i] 的有效性后，继续向前提升没有意义，而由于 s[i] 的字母序本身已经更大了，且 s[i] 的权重在 [i, n) 区间里是最高的，因此后面不管怎么填字典序都是更大的。那么，为了获得字典序最小的「下一个美丽字符串」，我们可以贪心地将后续字符降低到字母序最低的字母，例如 ”abcz“ 提升到 ”abdz” 后，将 ‘z’ 降低到 ‘a’。

这个思考过程，与「下一个排列」问题是比较相似的。在「下一个排列」问题中，我们交换尽可能靠后的一个正序对，由于剩下的序列不管怎么填都是更大的排列，所以我们直接对后续字母做正序排列可以得到最小的字典序。

**如何验证提升的有效性（提升字母序后会可能引入新的回文信息）？**

在「观察数据特征」中得知，输入字符串 s 本身就是「美丽字符串」，而且我们是从后向前提升字符，那么提升 s[i] 只可能构造出长度为 2 或长度为 3 的回文子串，我们需要以 i 为中心向左右扩展，验证是否有回文串信息。结合上一个问题，由于我们在提升 s[i] 后还需要降低后序位置的字母序，所以我们只需要向左边扩展验证有效性。

至此，我们可以确定整体框架，分为 2 个阶段：

```
阶段一：

提升 s[n - 1]
while (i 从后往前遍历) {
		for (c in s[i] + 1 until 'a' + k) { // 枚举字符集
				if (存在回文信息) continue
				s[i] = c // 确定有效性
				// 记录下标 i
		}
		// 无法提升 s[i]，尝试提升 s[i - 1]
}

阶段二：

// 将 [i + 1, n) 降低为最小字符
for(j in i + 1 until n) {
		for (c in 'a' until 'a' + k) { // 枚举字符集
				if (存在回文信息）continue
				s[j] = c
				break
		}
}
```

![](https://pic.leetcode.cn/1683353081-dpQFEs-Untitled%207.png){:width=400}

#### 答疑：

- 为什么阶段二没有处理无法构造的情况？

由于题目提示 k 的取值范围是大于等于 4 的，也就是字符集的大小最小为 4，而验证「有效性」只需要观察位置 i 的前两个位置。那么在长度为 3 的子区间 [i-2, i] 中，我们总能够从大小为 4 的字符集中，选择出一个不会构造出回文信息的子串。因此，阶段二是必然可构造的。甚至来说，题目将 k 的取值范围修改到 [3, 26]，我们的算法也是成立的。

## 题解（贪心）

```kotlin
class Solution {
    fun smallestBeautifulString(s: String, k: Int): String {
        val n = s.length
        val U = 'a' + k
        val sArray = s.toCharArray()
        var pos = -1
        outer@ for (i in n - 1 downTo 0) {
            // 尝试提升字母序
            for (c in sArray[i] + 1 until U) {
                // 验证有效性（只需要验证左边）
                if ((i > 0 && c == sArray[i - 1]) || (i > 1 && c == sArray[i - 2])) continue
                sArray[i] = c
                pos = i
                break@outer
            }
        }

        // 无法构造
        if (pos < 0) return ""

        for (i in pos + 1 until n) {
            for (c in 'a' until U) {
                // 验证有效性（只需要验证左边）
                if ((i > 0 && c == sArray[i - 1]) || (i > 1 && c == sArray[i - 2])) continue
                sArray[i] = c
                break
            }
        }

        return String(sArray)
    }
}
```

**复杂度分析：**

- 时间复杂度：$O(n)$ 其中 n 为字符串 s 的长度，每个位置最多被访问 2 次，而每个位置的提升操作最多执行 2 次，降低操作最多执行 2 次；
- 空间复杂度：$O(1)$ 不考虑结果数组。

**相似问题：**

- [31. 下一个排列](https://leetcode.cn/problems/next-permutation/)
- [647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/)
