## [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/description/)

## 题目描述

整数数组 nums 按升序排列，数组中的值 互不相同 。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。

给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。

你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

## 题目考点

二分查找

## 题解
 
1、判断当前处于左半区间还是右边区间，尝试区间有序部分
2、先写出与上一分支相同的逻辑，再反向推导判断条件

<img width="670" alt="image" src="https://user-images.githubusercontent.com/25008934/218065434-a88c17d6-1b3c-48f5-a782-a5e2ef324ff8.png">

```
class Solution {
    fun search(nums: IntArray, target: Int): Int {
        // 二分查找
        var left = 0
        var right = nums.size - 1
        while (left < right) {
            val mid = (left + right + 1) ushr 1
            // 1
            // 1,2
            // 3,1 target=3
            // 1,2,3,4,5,6,7
            // 4,5,6,7,0,1,2 target=6,target=2,target=4
            if (nums[mid] >= nums[0]) {
                // 可以确定 [0,mid] 是有序的，尝试趋向左边有序部分
                if (nums[mid] > target && target >= nums[0]) {
                    // 目标值位于左半有序区间
                    right = mid - 1
                } else {
                    left = mid
                }
            } else {
                // 可以确定 [mid,end] 是有序的，尝试区间右边有序部分
                //（为了保持逻辑一致，这里添加等号）
                if (nums[mid] <= target && target < nums[0]) {
                    left = mid
                } else {
                    right = mid - 1 // 先写出与上一分支相同的逻辑，再反向推导判断条件
                }
            }
        }
        return if (nums[left] == target) left else -1
    }
}
```

**复杂度分析：**

- 时间复杂度：O(lgn)
- 空间复杂度：O(1) 
