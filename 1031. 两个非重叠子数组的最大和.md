## [1031. 两个非重叠子数组的最大和](https://leetcode.cn/problems/maximum-sum-of-two-non-overlapping-subarrays/description/)

## 题目描述

给你一个整数数组 nums 和两个整数 firstLen 和 secondLen，请你找出并返回两个非重叠 子数组 中元素的最大和，长度分别为 firstLen 和 secondLen 。

长度为 firstLen 的子数组可以出现在长为 secondLen 的子数组之前或之后，但二者必须是不重叠的。

子数组是数组的一个 连续 部分。

## 题解（前缀和 + 滑动窗口）

```
class Solution {
    fun maxSumTwoNoOverlap(nums: IntArray, firstLen: Int, secondLen: Int): Int {
        // 贪心：优先选择某一种 x
        // 枚举：
        var ret = 0   
        val n = nums.size
        for(i in 0 until n) {
            if(i > 0) nums[i] += nums[i - 1]
        }
        // 枚举 firstLen 子数组，检查可行的 secondLen 子数组
        for(i in firstLen - 1 ..n - 1) {
            val firstSum = nums[i] - if(i - firstLen >= 0) nums[i - firstLen] else 0
            for (j in secondLen - 1 .. i - firstLen - 1) {
                val secondSum = nums[j] - if (j - secondLen >= 0) nums[j - secondLen] else 0
                ret = Math.max(ret, firstSum + secondSum) 
            }
            // println("[${secondLen - 1}, ${i - firstLen - 1}] i=$i, ret=$ret")
            for (j in i + secondLen .. n - 1) {
                val secondSum = nums[j] - if (j - secondLen >= 0) nums[j - secondLen] else 0
                ret = Math.max(ret, firstSum + secondSum) 
            }
            // println("[${i + secondLen} - ${n - 1}] i=$i, ret=$ret")
        }
        return ret
    }
}
```

**复杂度分析：**

- 时间复杂度：O(n)
- 空间复杂度：O(1)
