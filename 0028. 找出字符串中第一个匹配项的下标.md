## [28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)

## 题目描述

给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。

## 题目考点

常见的字符串匹配算法包括

- 暴力匹配
- Knuth-Morris-Pratt 算法
- Boyer-Moore 算法
- Sunday 算


- 暴力匹配会丢弃 “非完全匹配” 过程中的所有信息，造成重复匹配：一旦匹配失败，将会将原串指针调整至下一个「发起点」，匹配串的指针调整至起始位置，然后重新尝试匹配。时间复杂度是 O(nm)

![image](https://user-images.githubusercontent.com/25008934/222658321-77b13fba-7759-4d82-9f78-882354896c18.png)

- KMP 是一种快速查找匹配串的算法，其快速的关键在于在 “非完全匹配” 过程中提取并复用有效信息，以减少重复匹配：检查之前已经匹配成功的部分中里是否存在相同的「前缀」和「后缀」。如果存在，则跳转到「前缀」的下一个位置继续往下匹配

![image](https://user-images.githubusercontent.com/25008934/222658337-d4fa46c4-fe95-498c-8d70-af9eb3f3426a.png)

KMP 快在哪？

- 即利用已匹配部分中相同的「前缀」和「后缀」来加速下一次的匹配。
- 原串指针不会进行回溯（没有朴素匹配中回到下一个「发起点」的过程），随着匹配过程的进行，原串指针的不断右移，我们本质上是在不断地在否决一些「不可能」的方案。

还有一个问题，如何高效地计算 “已匹配部分的相同前缀和后缀” ？

- 1、使用 next 前缀表实现快速回退
- 2、next 数组存放的是当前长度下的 “最长相同前后缀” 的长度
- 3、匹配中止时，使用上一个匹配位置的 next 数组值 O(1) 获得 “已匹配部分的相同前缀和后缀”

`next 数组`

![](https://user-images.githubusercontent.com/25008934/222661478-28a75d30-2fba-4d2e-a9b7-63a05f32c95b.png)

如何 O(m) 时间构建 next 数组？

- next 数组基于 needle 数组
- 第 [0] 位为 0，表示不存在相同的前后缀
- j 指针从 0 开始，i 指针从 1 开始，在外层 i 指针的每一层循环中：
  - 如果 p[j] == p[i]，那么 next[i] = j + 1，并且 j 指针右移，表示匹配的前后缀长度 + 1
  - 如果 p[j] != p[i]，那么 j = next[j - 1]，表示回退到最长匹配前缀位置继续尝试匹配

case:
- abcabf
- 000120

`不匹配`
![](https://user-images.githubusercontent.com/25008934/222667911-4a94c0f0-1df9-4a00-96b8-208d00893716.png)

`回退 j 指针`
![](https://user-images.githubusercontent.com/25008934/222667998-f34d2733-7086-4fd7-ac8a-f5e0be45fe35.png)


参考：https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/575568/shua-chuan-lc-shuang-bai-po-su-jie-fa-km-tb86/
参考：https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/1119642/duo-tu-yu-jing-xiang-jie-kmp-suan-fa-by-w3c9c/

## 题解一（暴力匹配）

让字符串 needle 与字符串 haystack 的所有长度为 m 的子串均匹配一次

```
class Solution {
    fun strStr(haystack: String, needle: String): Int {
        val n = haystack.length
        val m = needle.length
        if (m == 0) return 0
        if (m > n) return -1
        outer@ for (i in 0..n - m) {
            for (offset in 0 until m) {
                if (haystack[i + offset] != needle[offset]) continue@ouuter
            }
            return i
        }
        return -1
    }
}
```

**复杂度分析：**

- 时间复杂度：O(nm)
- 空间复杂度：O(1) 

## 题解二（KMP）

```
class Solution {
    fun strStr(haystack: String, needle: String): Int {
        val n = haystack.length
        val m = needle.length
        if (m == 0) return 0
        if (m > n) return -1
        // 1、前后缀匹配长度
        val next = IntArray(n) { 0 }
        var j = 0
        for (i in 1 until m) {
            // 未匹配回退 j 指针
            while (j > 0 && needle[i] != needle[j]) {
                j = next[j - 1]
            }
            if (needle[i] == needle[j]) j++
            next[i] = j
        }
        // 2、字符串匹配
        j = 0
        for (i in 0 until n) {
            // 未匹配回退 j 指针
            while (j > 0 && haystack[i] != needle[j]) {
                j = next[j - 1]
            }
            // 匹配位置 + 1
            if (haystack[i] == needle[j]) j++
            // 完全匹配
            if (j == m) return i - m + 1
        }
        return -1
    }
}
```

**复杂度分析：**

- 时间复杂度：O(n + m)
- 空间复杂度：O(1) 
