## [274. H 指数](https://leetcode.cn/problems/h-index/description/)

某人的 h 指数是 20，这表示他已发表的论文中，每篇被引用了至少 20 次的论文总共有 20 篇。

按照升序排序，题目其实要我们找的是一条分割线，这条分割线的含义是：分割线右边的所有论文的引用次数都很高，并且：分割线右边的最少引用次数 >= 分割线右边的论文篇数。

参考：https://leetcode.cn/problems/h-index/solutions/870465/er-fen-cai-lun-wen-pian-shu-java-by-liwe-zoh7/

## 题解一（排序 + 线性）

```
class Solution {
    fun hIndex(citations: IntArray): Int {
        citations.sort()
        var h = 0
        for (i in citations.size - 1 downTo 0) {
            if (citations[i] <= h) break
            // citations[i] 需要大于 h，才能构造引用次数大于等于 h 的论文数为 h
            // eg：1 1 3
            h++
        }
        return h
    }
}
```

- O(nlgn + n)
- O(lgn)

## 题解二（计数排序 + 线性）

```
class Solution {
    fun hIndex(citations: IntArray): Int {
        // 计算引用次数的出现次数
        val n = citations.size
        val cnt = IntArray(n + 1)
        for (i in 0 until n) {
            cnt[Math.min(n, citations[i])] ++
        }
        var sum = 0
        for (h in n downTo 0) {
            sum += cnt[h]
            // 终止条件：存在至少 h 篇论文的引用次数为 h
            if (sum >= h) return h
        }
        return 0
    }
}
```

- O(n)
- O(n)

## 题解三（排序 + 二分）

```
class Solution {
    fun hIndex(citations: IntArray): Int {
        // 0 1 3 5 6
        // 0 1 2 5 6
        val n = citations.size
        // 排序
        citations.sort()
        // 二分寻找满足条件的第一个元素
        var left = 0
        var right = n - 1
        while (left < right) {
            val mid = (left + right) ushr 1
            if (citations[mid] >= n - mid) {
                right = mid
            } else {
                left = mid + 1
            }
        }
        return if (citations[left] >= n - left) n - left else 0
    }
}
```

- O(nlgn + lgn)
- O(lgn)
