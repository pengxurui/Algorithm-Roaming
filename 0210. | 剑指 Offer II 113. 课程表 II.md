## [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/description/)
## [剑指 Offer II 113. 课程顺序](https://leetcode.cn/problems/QA2IGt/)

## 题目描述

现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ，其中 prerequisites[i] = [ai, bi] ，表示在选修课程 ai 前 必须 先选修 bi 。

例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。
返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组 。

## 题目考点

图、拓扑排序

## 题解一
 
```
class Solution {
    fun findOrder(numCourses: Int, prerequisites: Array<IntArray>): IntArray {
        // 入度表
        val inDegrees = IntArray(numCourses)
        // 邻接表
        val graph = HashMap<Int, MutableList<Int>>()
        // 队列
        val queue = LinkedList<Int>()
        // 计数
        var ret = LinkedList<Int>()
        for (prerequisite in prerequisites) {
            graph.getOrPut(prerequisite[1]) { LinkedList<Int>() }.add(prerequisite[0])
            inDegrees[prerequisite[0]]++
        }
        // 拓扑排序：
        // 将入度为 0 的节点入队
        for (index in inDegrees.indices) {
            if (inDegrees[index] == 0) queue.offer(index)
        }
        while (!queue.isEmpty()) {
            // 删除入度为 0 的节点
            val node = queue.poll()
            // 修改相邻节点
            for (edge in graph[node] ?: Collections.emptyList()) {
                if (--inDegrees[edge] == 0) queue.offer(edge)
            }
            ret.add(node)
        }
        return if(ret.size == numCourses) ret.toIntArray() else IntArray(0)
    }
}
```

**复杂度分析：**

- 时间复杂度：O(n + m)
- 空间复杂度：O(n + m) 

## 题解二

```
class Solution {
    fun findOrder(numCourses: Int, prerequisites: Array<IntArray>): IntArray {
        // 领接表
        val graph = HashMap<Int, LinkedList<Int>>().apply {
            for (prerequisite in prerequisites) {
                this.getOrPut(prerequisite[0]) { LinkedList<Int>() }.add(prerequisite[1])
            }
        }
        // 0：未搜索、1：搜索中、2：已完成
        val flags = IntArray(numCourses)
        val ret = LinkedList<Int>()
        // DFS
        for (index in flags.indices) {
            if (0 == flags[index]) {
                if (!dfs(graph, flags, index, ret)) return IntArray(0)
            }
        }
        return if (ret.size == numCourses) ret.toIntArray() else IntArray(0)
    }

    private fun dfs(graph: Map<Int, List<Int>>, flags: IntArray, index: Int, path: MutableList<Int>): Boolean {
        // 标记搜索中
        flags[index] = 1
        for (edge in graph[index] ?: Collections.emptyList()) {
            // 成环
            if (flags[edge] == 1) return false
            if (flags[edge] == 2) continue
            // 递归
            if (!dfs(graph, flags, edge, path)) return false
        }
        // 标记已完成
        flags[index] = 2
        path.add(index)
        return true
    }
}
```

**复杂度分析：**

- 时间复杂度：O(n + m)
- 空间复杂度：O(n + m) 
