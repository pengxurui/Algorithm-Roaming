## [2592. 最大化数组的伟大值](https://leetcode.cn/problems/maximize-greatness-of-an-array/description/)

## 题目描述

给你一个下标从 0 开始的整数数组 nums 。你需要将 nums 重新排列成一个新的数组 perm 。

定义 nums 的 伟大值 为满足 0 <= i < nums.length 且 perm[i] > nums[i] 的下标数目。

请你返回重新排列 nums 后的 最大 伟大值。

### 题解一（贪心 / 田忌赛马）

贪心思路：田忌赛马，以下赛马策略最优：

- 田忌的中等马对齐威王的下等马，田忌胜；
- 田忌的上等马对齐威王的中等马，田忌胜；
- 田忌的下等马对齐威王的下等马，齐威王胜。

回到本题，考虑一组贡献伟大值的配对 $(p, q)$，其中 $p < q$。由于越小的值越匹配到更大值，为了让结果最优，应该让 p 尽可能小，即优先匹配 nums 数组的较小值。那么 $q$ 如何选择呢？有 2 种策略：

- 策略 1 - 优先匹配最大值：无法得到最优解，因为会消耗了较大的 q 值，可能导致部分 p 值无法匹配（如果田忌用上等马对齐威王的下等马，最终将是齐威王生出）；
- 策略 2- 优先匹配最接近的更大值：最优解，即田忌赛马策略，以 [1,1,1,2,3,3,5] 为例：
    - 初始状态 i = 0，j = 0；
    - i = 0，j = 0，无法贡献伟大值，j 自增 1（寻找最接近的更大值）；
    - i = 0，j = 1， 无法贡献伟大值，j 自增 1；
    - i = 0，j = 2， 无法贡献伟大值，j 自增 1；
    - i = 0，j = 3， 贡献伟大值，j 自增 1，i 自增 1；
    - i = 1，j = 4， 贡献伟大值，j 自增 1，i 自增 1；
    - i = 2，j = 5， 贡献伟大值，j 自增 1，i 自增 1；
    - i = 3，j = 6， 贡献伟大值，j 自增 1，i 自增 1；
    - 退出循环，i = 4；正好等于伟大值 4。

```kotlin
class Solution {
    fun maximizeGreatness(nums: IntArray): Int {
        nums.sort()
        // i：参与匹配的指针
        var i = 0
        for (num in nums) {
            // 贡献伟大值
            if (num > nums[i]) i++
        }
        return i
    }
}
```

**复杂度分析：**

- 时间复杂度：$O(nlgn + n)$ 排序 + 线性遍历，其中 $n$ 是 $nums$ 数组长度；
- 空间复杂度：$O(lgn)$ 排序递归栈空间。

### 题解二（最大重复计数）

竞赛中从测试用例中观察到题解与最大重复数存在关系，例如：

- 用例 [1,1,1,2,3,3,5]：最大重复数为 3，一个最优方案为 [2,3,3,5,x,x,x]，最大伟大值为 7 - 3 = 4，其中 7 是数组长度；
- 用例 [1,2,2,2,2,3,5]：最大重复数为 4，一个最优方案为 [2,3,5,x,x,x,x]，最大伟大值为 7 - 4 = 3，其中 7 是数组长度；
- 用例 [1,1,2,2,2,2,3,3,5]，最大重复数为 4，一个最优方案为 [2,2,3,3,5,x,x,x,x]，最大伟大值为 9 - 4 = 5，其中 9 是数组长度。

我们发现题目的瓶颈在于数字最大重复出现计数。最大伟大值正好等于 **数组长度 - 最大重复计数。**

如何证明？关键在于 i 指针和 j 指针的最大距离：

当 i 指针指向重复元素的首个元素时（例如下标为 0、2、6 的位置），j 指针必须移动到最接近的较大元素（例如下标为 2，6，8 的位置）。而 i 指针和 j 指针的最大错开距离取决于数组重复出现次数最多的元素，只要错开这个距离，无论数组后续部分有多长，都能够匹配上。

![](https://pic.leetcode.cn/1679387465-JuTZgf-Untitled%204.png){:width=400}

```kotlin
class Solution {
    fun maximizeGreatness(nums: IntArray): Int {
        var maxCnt = 0
        val cnts = HashMap<Int, Int>()
        for (num in nums) {
            cnts[num] = cnts.getOrDefault(num, 0) + 1
            maxCnt = Math.max(maxCnt, cnts[num]!!)
        }
        return nums.size - maxCnt
    }
}
```

**复杂度分析：**

- 时间复杂度：$O(n)$ 其中 $n$ 是 $nums$ 数组的长度；
- 空间复杂度：$O(n)$ 其中 $n$ 是 $cnts$ 散列表空间。
