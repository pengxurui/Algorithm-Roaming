## [313. 超级丑数](https://leetcode.cn/problems/super-ugly-number/description/)
## [264. 丑数 II](https://leetcode.cn/problems/ugly-number-ii/description/)

- 我们「往后产生的丑数」都是基于「已有丑数」而来（使用「已有丑数」乘上「给定质因数」primes[i]）。
- 相比于「丑数 II」要求所有因子都在 primes 列表中

## 题解一（小顶堆 + 散列表）

```
class Solution {
    fun nthSuperUglyNumber(n: Int, primes: IntArray): Int {
        val heap = PriorityQueue<Long>()
        val set = HashSet<Long>()
        heap.offer(1)
        set.add(1)
        var cnt = n - 1
        while (cnt > 0) {
            val cur = heap.poll()
            for (prime in primes) {
                val key = 1L * prime * cur
                if (!set.contains(key)) {
                    set.add(key)
                    heap.offer(key)
                }
            }
            cnt --
        }
        return heap.poll().toInt()
    }
}
```

- O(nmlg(nm)) 需要从优先队列（堆）中弹出 n 个元素，每次弹出最多需要放入 m 个元素，堆中最多有 nm 个元素
- O(nm)

## 题解二（动态规划 + 小顶堆）

维护每个序列的编号

```
```
