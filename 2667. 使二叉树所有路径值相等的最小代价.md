## [2667. 使二叉树所有路径值相等的最小代价](https://leetcode.cn/problems/make-costs-of-paths-equal-in-a-binary-tree/)

## 题目描述

给你一个整数 n 表示一棵 满二叉树 里面节点的数目，节点编号从 1 到 n 。根节点编号为 1 ，树中每个非叶子节点 i 都有两个孩子，分别是左孩子 2 * i 和右孩子 2 * i + 1 。

树中每个节点都有一个值，用下标从 0 开始、长度为 n 的整数数组 cost 表示，其中 cost[i] 是第 i + 1 个节点的值。每次操作，你可以将树中 任意 节点的值 增加 1 。你可以执行操作 任意 次。

你的目标是让根到每一个 叶子结点 的路径值相等。请你返回 最少 需要执行增加操作多少次。

注意：

满二叉树 指的是一棵树，它满足树中除了叶子节点外每个节点都恰好有 2 个节点，且所有叶子节点距离根节点距离相同。
路径值 指的是路径上所有节点的值之和。

### 问题结构化

![](https://pic.leetcode.cn/1683468511-yemwbV-T4.jpg){:width=400}

#### 1、概括问题目标

计算将所有「根到叶子结点的路径和」调整到相同值的操作次数。

#### 2、分析问题要件

在每一次操作中，可以提高二叉树中某个节点的数值，最终使得该路径和与所有二叉树中其他所有路径和相同。

#### 3、观察问题数据

- 满二叉树：输入数据是数组物理实现的二叉树，二叉树每个节点的初始值记录在 cost 数组上；
- 数据量：输入数据量的上界为 10^5，这要求算法的时间复杂度不能高于 O(n^2)；
- 数据大小：二叉树节点的最大值为 10^4，即使将所有节点都调整到 10^4 路径和也不会整型溢出，不需要考虑大数问题。

#### 4、提高抽象程度

- 最大路径和：由于题目只允许增加节点的值，所以只能让较小路径上的节点值向较大路径上的节点值靠；
- 公共路径：对于节点「2」的子节点「4」和「5」来说，它们的「父节点和祖先节点走过的路径」必然是公共路径。也就是说，无论从根节点走到节点「2」的路径和是多少，对节点 A 和节点 B 的路径和的影响是相同的。
- 是否为决策问题：由于每次操作可以调整的选择性很多，因此这是一个决策问题。

#### 5、具体化解决方案

**如何解决问题？**

结合「公共路径」思考，由于从根节点走到节点「2」的路径和对于两个子节点的影响是相同的，因此对于节点「2」来说，不需要关心父节点的路径和，只需要保证以节点「2」为根节点的子树上所有路径和是相同的。这是一个规模更小的相似子问题，可以用递归解决。

`示意图`

![](https://files.mdnice.com/user/3257/304b2000-ccdb-417e-a6b4-3e564309d773.png)

**如何实现递归函数？**

- 思考终止条件：当前节点为叶子节点时，由于没有子路径，所以直接返回；
- 思考小规模问题：当子节点为叶子节点时，我们只需要保证左右两个叶子节点的值相同（如示例 1 中将节点「4」的值增加到 3）。由于问题的输入数据是满二叉树，所以左右子节点必然同时存在；
- 思考大规模问题：由于我们保证小规模子树的路径和相同，所以在对比两个子树上的路径和时，只需要调大最小子树的根节点。

至此，我们的递归函数框架确定：

```
全局变量 int ret
// 返回值：调整后的子树和
fun dfs (i) : Int {
		val sumL = dfs(L)
		val sumR = dfs(R)
		ret += max(sumL, sumR) - min(sumL, sumR) 
		return cost[i] + max(sumL, sumR)
}
```

#### 6、是否有优化空间

我们使用递归自顶向下地分解子问题，再自底向上地求解原问题。由于这道题的输入是数组形式的满二叉树，对于数组实现的二叉树我们可以直接地从子节点返回到父节点，而不需要借助「递归栈」后进先出的逻辑，可以翻译为迭代来优化空间。

#### 7、答疑

**虽然我们保证子树上的子路径是相同的，但是如何保证最终所有子路径都和「最大路径和」相同？**

由于我们不断地将左右子树的路径和向较大的路径和对齐，因此最终一定会将所有路径对齐到最大路径和。

**为什么算法的操作次数是最少的？**

首先，由于左右子树存在「公共路径」，因此必须把左右子树的子路径和调整到相同数值，才能保证最终所有子路径和的长度相同。

其次，当在大规模子树中需要增大路径和时，在父节点操作可以同时作用于左右子路径，因此在父节点操作可以节省操作次数，每个子树只关心影响当前子树问题合法性的因素。

### 题解一（DFS）

根据「问题结构化」分析的递归伪代码实现：

```kotlin
class Solution {

    private var ret = 0

    fun minIncrements(n: Int, cost: IntArray): Int {
        dfs(n, cost, 1)
        return ret
    }

    // i : base 1
    // cost : base 0
    // return: 调整后的子路径和
    private fun dfs(n: Int, cost: IntArray, i: Int): Int {
        // 终止条件
        if (i > n / 2) return cost[i - 1] // 最后一层是叶子节点
        // 子问题
        val leftSum = dfs(n, cost, i * 2)
        val rightSum = dfs(n, cost, i * 2 + 1)
        // 向较大的子路径对齐
        ret += Math.max(leftSum, rightSum) - Math.min(leftSum, rightSum)
        return cost[i - 1] + Math.max(leftSum, rightSum)
    }
}
```

**复杂度分析：**

- 时间复杂度：$O(n)$ 其中 n 为 节点数，每个节点最多访问 1 次；
- 空间复杂度：$O(lgn)$ 递归栈空间，由于输入是满二叉树，所以递归栈深度最大为 lgn。

### 题解二（迭代）

由于输入数据是满二叉树，而且是以数组的形式提供，因此我们可以跳过递归分解子问题的过程，直接自底向上合并子问题：

```kotlin
class Solution {
    fun minIncrements(n: Int, cost: IntArray): Int {
        var ret = 0
        // 从叶子的上一层开始
        for (i in n / 2 downTo 1) {
            ret += Math.abs(cost[i * 2 - 1] - cost[i * 2])
            // 借助 cost 数组记录子树的子路径和
            cost[i - 1] += Math.max(cost[i * 2 - 1], cost[i * 2])
        }
        return ret
    }
}
```

**复杂度分析：**

- 时间复杂度：$O(n)$ 其中 n 为 节点数，每个节点最多访问 1 次；
- 空间复杂度：$O(1)$ 仅使用常量级别空间。
