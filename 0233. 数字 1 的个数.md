## [233. 数字 1 的个数](https://leetcode.cn/problems/number-of-digit-one/description/)

## 题目描述

给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。

## 题目考点

数位 DP

## 题解一（暴力 · 超出时间限制）

枚举区间中的每个数，计算 1 的数量

```
class Solution {
    fun countDigitOne(n: Int): Int {
        var cnt = 0
        for (num in 1..n) {
            var x = num
            while (x > 0) {
                if (x % 10 == 1) cnt++
                x /= 10
            }
        }
        return cnt
    }
}
```

**复杂度分析：**

- 时间复杂度：O(nlgn)
- 空间复杂度：O(1) 

## 题解二（朴素动态规划 · 超出内存限制）

将数字 i 拆分为两部分，例如将数字 123 拆分为 12 和 3 两部分，则有 dp[i] = dp[i / 10] + dp[i % 10]

从小到大枚举 i，则子问题已经已经计算过。

```
class Solution {
    fun countDigitOne(n: Int): Int {
        if (n == 0) return 0
        var cnt = 0
        val dp = IntArray(n + 1)
        dp[1] = 1
        for (i in 1..n) {
            dp[i] = dp[i / 10] + dp[i % 10]
            cnt += dp[i]
        }
        return cnt
    }
}
```

**复杂度分析：**

- 时间复杂度：O(n)
- 空间复杂度：O(n) 

## 题解三（组合 + 记忆化递归）

可见：任何枚举数字本身的算法复杂度无法满足需求，既然无法枚举数本身，那么是否可以枚举数位呢？比如先计算个位上 1 出现的次数，再计算十位上 1 出现的次数。

因此，我们尝试用组合的思路：

- 定义 f(i, cnt, isLimit, isNum) 表示在第 i - 1 位（从高到低）已经出现 cnt_i 个 1 的状态下，继续构造第 i 位时会得到 1 的个数
  - cnt 的定义：前一个状态的解
  - isLimit 的定义：是否只能填到 s[i]，例如在 n = 1234 中，百位被限制且填了上界 2，则十位数最高只能填到 s[i] = 3；如果百位未被限制或填了 1，则十位数最高可以填到 9；
  - isNum 的定义：是否可以填写 0，否则可以跳过或填至少为 1 的数，例如在 n = 1234 中，千位数跳过，则百位数可以跳过或填 1；如果千位数填了数字，则百位数可以填写从 0 开始的任何数；

在这道题中：
- 由于前导 0 对结果没有影响，所以我们可以去掉 isNum 参数，视 0012 合法。
- 由于 isLimit 的约束在整个递归过程中只会出现一次，因此没必要作为记忆化的维度。例如在 n = 1234 中，千位对百位的位数只会出现一次。
- 由于每一位上 isLimit 是最后出现的状态，为了避免脏数据，记忆化只有在 isLimit 为 false 时使用，为什么呢？设一个数字为 303，如果第一位小于 3，那么后面几位就没有任何限制，可以任意取，在这个过程中就会给 dp[i][j] 进行赋值，如果第一位取 3，那么第二位就只能取 0，如果仍然按照没有 isLimit 的限制去取值，就会取到第二位为 1 的情况，此时数字就会大于原数字，所以需要在 isLimit 的限制下保存值

参考：https://leetcode.cn/problems/number-of-digit-one/solutions/1750339/by-endlesscheng-h9ua/

```
class Solution {
    fun countDigitOne(n: Int): Int {
        val str = "$n".toCharArray()
        val m = str.size
        return f(str, 0, 0, true, Array(m) { IntArray(m) { -1 } })
    }

    private fun f(str: CharArray, i: Int, lastCnt: Int, isLimit: Boolean, memo: Array<IntArray>): Int {
        if (i == str.size) return lastCnt
        if (!isLimit && memo[i][lastCnt] >= 0) return memo[i][lastCnt]
        var curCnt = 0
        // 枚举选项
        val lower = 0
        val upper = if (isLimit) str[i] - '0' else 9
        for (choice in lower..upper) {
            // 递归
            curCnt += f(str, i + 1, lastCnt + if (choice == 1) 1 else 0, isLimit && choice == upper, memo)
        }
        // 记忆化
        if (!isLimit) memo[i][lastCnt] = curCnt
        return curCnt
    }
}
```

**复杂度分析：**

- 时间复杂度：O(m) m 是位数（lgn）
- 空间复杂度：O(m^2) m 很小，m^2 最高不超过 100

## 题解四（找规律 + 数位 DP）

这道题的标准解法应该是数位 DP

- 数位 DP 一般用于解决整数计数问题，例如本题中计算所有数字范围中数字 1 出现的次数
- 数位 DP 的大致思路是按位讨论：依次讨论从高位到低位的情况，并寻找位之间的递推关系
- 由于题目给出的范围一般不会是完整区间，因此数位 DP 需要考虑整项和余项两种情况：
  - 整项：完整的一次循环，例如 [0,9] 是一个一位数整项，[0,99] 是一个二位数整项，[0,999] 是一个三位数整项
  - 余项：去掉最高位后剩余的部分，例如 2876 有两个 [0,999] 的三位数整项，余项是 876 [2000,2876]

以 n = 1234567 的百位为例：

- 整项部分：对于每一轮最低位 [000,999] 的循环中，百位在 [100, 199] 共计 100 次 1，这部分整项中位 1 出现的次数为 n / 1000 * 100
- 余项部分（567）n` = n mod 100：
  - 如果 n` < 100，则百位不会出现 1，出现次数为 0；
  - 如果 100 <= n`< 200，则百位出现 1 的次数为 n` - 100 + 1
  - 如果 n` > 200，则百位正好出现 [100,199] 共计 100 次 1
  - 整理得余项部分 = min{max(n` - 100 + 1, 0), 100}
- 两部分相加得：n / 1000 * 100 + min{max(n` - 100 + 1, 0), 100}

从百位演绎到一般情况 i 位（从右到左）：n / 10^(k+1) * 10^k + min{max(n mod 10^(k+1) - 10^k + 1, 0), 10^k}

```
class Solution {
    fun countDigitOne(n: Int): Int {
        var mulK = 1L
        var cnt = 0L
        while (n >= mulK) {
            cnt += (n / (mulK * 10) * mulK) + Math.min(Math.max(n % (mulK * 10) - mulK + 1, 0), mulK)
            mulK *= 10L
        }
        return cnt.toInt()
    }
}
```

**复杂度分析：**

- 时间复杂度：O(m) m 是位数（lgn）
- 空间复杂度：O(1) 
