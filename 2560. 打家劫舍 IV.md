## [2560. 打家劫舍 IV](https://leetcode.cn/problems/house-robber-iv/description/)

## 题目描述

沿街有一排连续的房屋。每间房屋内都藏有一定的现金。现在有一位小偷计划从这些房屋中窃取现金。

由于相邻的房屋装有相互连通的防盗系统，所以小偷 不会窃取相邻的房屋 。

小偷的 窃取能力 定义为他在窃取过程中能从单间房屋中窃取的 最大金额 。

给你一个整数数组 nums 表示每间房屋存放的现金金额。形式上，从左起第 i 间房屋中放有 nums[i] 美元。

另给你一个整数 k ，表示窃贼将会窃取的 最少 房屋数。小偷总能窃取至少 k 间房屋。

返回小偷的 最小 窃取能力。

## 题解

```
class Solution {
    fun minCapability(nums: IntArray, k: Int): Int {
        if (nums.isEmpty()) return 0
        if (k > (nums.size + 1) / 2) return -1
        // 窃取金额越大，可窃取次数也越大，存在单调性，可以用二分查找解决
        var left = 0
        var right = 10e9.toInt()
        while (left < right) {
            val mid = (left + right) ushr 1
            if (check(nums, k, mid)) {
                right = mid
            } else {
                left = mid + 1
            }
        }
        return left
    }

    // 窃取能力 x 能否窃取不少于 k 间房屋
    private fun check(nums: IntArray, k: Int, x: Int): Boolean {
        // dp[i] 表示最大窃取次数
        var f0 = 0
        var f1 = 0
        for (i in 0 until nums.size) {
            var newF = f1
            if (nums[i] <= x) {
                newF = Math.max(f1, f0 + 1)

            }
            f0 = f1
            f1 = newF
        }
        return f1 >= k
    }
}
```

**复杂度分析：**

- 时间复杂度：O(nlgU)
- 空间复杂度：O(1)
