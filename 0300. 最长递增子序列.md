## [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/description/)

## 题目描述

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

## 题目考点

动态规划

参考：https://leetcode.cn/problems/longest-increasing-subsequence/solutions/147667/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/

## 题解一（动态规划）

如果一个较大的数接在较小的数后面，就会形成一个更长的子序列。只要 nums[i] 严格大于在它位置之前的某个数，那么 nums[i] 就可以接在这个数后面形成一个更长的上升子序列

```
class Solution {
    fun lengthOfLIS(nums: IntArray): Int {
        // 动态规划：dp[index] 表示以 nums[index] 为结尾的最长递增子序列长度
        // 0,3,1,6,2,2,7
        val n = nums.size
        // 子序列长度最少为 1
        val dp = IntArray(n) { 1 }
        var result = 1
        for (i in nums.indices) {
            for (j in 0..i - 1) {
                if (nums[j] < nums[i]) dp[i] = Math.max(dp[i], dp[j] + 1)
            }
            result = Math.max(result, dp[i])
        }
        return result
    }
}
```

**复杂度分析：**

- 时间复杂度：O(n^2)
- 空间复杂度：O(n) 

## 题解二（动态规划 + 贪心 + 二分查找)

贪心思路：要使得长度最长，我们期望每次添加的元素尽可能小，才能让递增竟可能慢。

因此：我们维护一个数组 d[i] ，表示长度为 i 的最长上升子序列的末尾元素的最小值，用 len 记录目前最长上升子序列的长度，起始时 lenl 为 1，d[1]=nums[0]。

同时我们发现：d[i] 是单调递增的，可以利用二分查找

算法整体思路：

设当前已求出的最长上升子序列的长度为 len（初始时为 1，dp[1] = nums[0], 下标从 1 开始），从前往后遍历数组 nums，在遍历到 nums[i] 时：

如果 nums[i]>d[len] ，则说明找到更长的递增子序列，那么直接加入到 d 数组末尾，并更新 len=len+1；

否则，说明无法实现更长的递增子序列，那么需要维护 d 数组的定义，让序列的末尾元素尽可能小：将 d[0,len) 之间大于 nums[i] 的第一个元素替换为 nums[i]

举例：以输入序列 [0,8,4,12,2] 为例：

第一步插入 0，d=[0];

第二步插入 8，d=[0,8];

第三步插入 4，d=[0,4]; [0,4] 优于 [0,8]

第四步插入 12，d=[0,4,12];

第五步插入 2，d=[0,2,12]. [0,2] 优于 [0,4]

```
class Solution {
    fun lengthOfLIS(nums: IntArray): Int {
        // 动态规划：以 index 为长度的子序列的最后一位元素
        val n = nums.size
        var dp = IntArray(n + 1)
        var len = 1
        dp[1] = nums[0]
        for (index in 1 until nums.size) {
            if (nums[index] > dp[len]) {
                // 找到更长的子序列
                dp[++len] = nums[index]
            } else {
                // 二分查找维护增长更慢的序列
                var left = 1
                var right = len
                while (left < right) {
                    val mid = (left + right) ushr 1
                    if (dp[mid] < nums[index]) {
                        left = mid + 1
                    } else {
                        right = mid
                    }
                }
                dp[left] = nums[index]
            }
        }
        return len
    }
}
```

**复杂度分析：**

- 时间复杂度：O(nlgn)
- 空间复杂度：O(n) 
