## [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)

## 题目描述

给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。

返回 你能获得的 最大 利润 。

## 题目考点

动态规划、贪心

## 题解一（动态规划）
 
今天买入的最大利润：max{昨天已持有状态的利润，昨天未持有状态的例如 - 今天买入价格}

关于 dp[index][0] - prices[index] 与 dp[index - 1][0] - prices[index] 结果相同的问题：

这是因为 dp[index][0] 的 max{} 中已经存在 dp[index - 1][0] 的因子

无论题目中是否允许「在同一天买入并且卖出」这一操作，最终的答案都不会受到影响，这一操作带来的收益为零

```
class Solution {
    fun maxProfit(prices: IntArray): Int {
        // 动态规划
        val dp = Array(prices.size) { IntArray(2) }.apply {
            this[0][0] = 0
            this[0][1] = - prices[0]
        }
        for (index in 1 until prices.size) {
            dp[index][0] = Math.max(dp[index - 1][0], dp[index - 1][1] + prices[index])
            dp[index][1] = Math.max(dp[index - 1][1], dp[index][0] - prices[index])
        }
        return dp[prices.size - 1][0]
    }
}
```

```
class Solution {
    fun maxProfit(prices: IntArray): Int {
        // 动态规划 + 滚动数组
        val dp = IntArray(2).apply {
            this[0] = 0
            this[1] = -prices[0]
        }
        for (index in 1 until prices.size) {
            dp[0] = Math.max(dp[0], dp[1] + prices[index])
            dp[1] = Math.max(dp[1], dp[0] - prices[index])
        }
        return dp[0]
    }
}
```

**复杂度分析：**

- 时间复杂度：O(n)
- 空间复杂度：O(1) 

## 题解二（贪心）

我们发现题目存在贪心规律：

- 连续上涨周期：每天都交易可以获得最大利润：且每两天交易和首尾两天交易的利润相同
- 连续下降周期：同理

```
class Solution {
    fun maxProfit(prices: IntArray): Int {
        var result = 0
        for (index in 1 until prices.size) {
            val diff = prices[index] - prices[index - 1]
            if (diff > 0) result += diff
        }
        return result
    }
}
```

**复杂度分析：**

- 时间复杂度：O(n)
- 空间复杂度：O(1) 
